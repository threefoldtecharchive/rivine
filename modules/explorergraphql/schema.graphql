schema {
    query: QueryRoot
}

# TODO: provide also unconfirmed updates if desired for wallets

# TODO: what other things should provide unconfirmed updates????

# TODO: even if we have pagination support, a user might still be able to ask too much data,
#    by requesting an unreasonable level of recursive nesting. We should limit this also somehow...

# TODO: How to query transactions based on properties
# TODO: How to query wallets based on properties

# TODO: support providing arguments to certain field resolvers,
#    ... for example: allowing only the first item of a list to be retuned (e.g. payout)

type QueryRoot {
  """
  Query the chain facts, for constant, aggregated and contemporary data.
  Constant data allows you to learn more about the network configuration,
  aggregated data allows you have a quick overview of the amount of coins
  and blocks available (locked or unlocked), and the contemporary data
  allows you to know the latest block the chain is on (and thus
  also the chain time and height).
  """
  chain: ChainFacts

  """
  Query an object, which can be a wallet, contract, block, transaction or output.
  If no identifier is given the latest block will be returned.
  """
  object(id: ObjectID): Object

  """
  Query a block by identifier.
  If no Hash is given, the latest block will be
  returned.
  """
  block(id: Hash): Block

  """
  Query a block by position.
  If no position is given, the latest block will be returned.
  Use a negative position to choose a block starting from the latest block,
  for example -2 for the 2nd last block, and -1 for the last block.
  The genesis block is at position 0 and the numbering goes upwards from there.
  """
  blockAt(position: Int): Block

  """
  Query multiple blocks, optionally giving a filter.
  If no filter is given the first blocks at the start are given.
  This query uses pagination and will have a server-defined upper limit
  of items to return maximum. In case more items can be returned,
  follow-up call(s) have to be made, using the returned Cursor
  as a FilterSinceCursor.
  """
  blocks(filter: BlocksFilter): ResponseBlocks

  """
  Query a transaction by identifier.
  For transaction version specific information the desired
  types have to be checked using the union-on GraphQL selection in your query.
  Please consult the Transaction interface implementations to know
  which versions are available and how they are typed in this API.
  """
  transaction(id: Hash!): Transaction

  """
  Query an output by identifier.
  An input can be queried as well by querying the output,
  the input data will be available as spenditure data on the returned output.
  Please consult the `OutputType` enum to know what Outputs are supported
  by this API.
  """
  output(id: Hash!): Output

  """
  Query a wallet by its address (a more human friendly name for unlockhash).
  Please consult the Wallet implementations t oknow
  which wallet types are available in this API and how they are typed.
  """
  wallet(unlockhash: UnlockHash!): Wallet

  """
  Query a contract by its address (a more human friendly name for unlockhash).
  Please consult the Contract union type to know what contracts are available
  and how they are typed in this API.
  """
  contract(unlockhash: UnlockHash!): Contract
}

"""
ObjectID is the generic identifier type for an object.
Can be a crypto (blake2b_256) `Hash` (for block-, transaction-, and output identifiers),
or an `UnlockHash` (for any kind of wallet or contract).
"""
scalar ObjectID
"""
BlockHeight is implemented as an unsigned 64-bit integer,
and represents the height of a block, stargting at 0.
"""
scalar BlockHeight
"""
Timestamp is implemented as an unsigned 64-bit integer,
and represents the UNIX Epoch Timestamp (in seconds).
"""
scalar Timestamp
"""
Hash represents a crypto (blake2b_256) `Hash` (a byte array of fixed length 32),
and is used as the identifier for blocks, transactions and outputs.
Within the context of this API it is always hex-encoded.
"""
scalar Hash
"""
UnlockHash represents an address of a wallet or contract,
and can be stored as a fixed array of 32 bytes (the hash part) as well as one byte for the type.
Within the context of this API it is always hex-encoded,
where the first 2 characters represent the type byte, the next 64 characters represent
the hex-encoded hash and the last 12 characters represent the hex-encoded 6-byte checksum.
Please consult https://github.com/threefoldtech/rivine/blob/master/doc/transactions/unlockhash.md#textstring-encoding
for more information about the full details of the encoding used for this type within the context of this API.
"""
scalar UnlockHash
"""
LockTime is perhaps an unfortunate name and is is used for places where either a `BlockHeight`
or `Timestamp` is used. It is named like this for historic reasons, as a block height can also be seen as some kind of time unit.
"""
scalar LockTime
"""
BinaryData is the scalar type used by this API as the go-to
binary byte-slice type. It is always hex-encoded within the context of this API.
"""
scalar BinaryData
"""
PublicKey is the go-to type of this API for cryptographic public keys.
Within the context of this API it is encoded as a 2 part string, separated by a colon,
with the first part identifying the cryptographic algorithm and the second part the hex-encoded
public key (currently always 32 bytes, or 64 characters hex-encoded, at the moment).
At the moment only one cryptographic (signature) algorithm is supported.
This algorithm is ED25119 and identifier as `ed25519`.
Please see documentation such as
https://github.com/threefoldtech/rivine/blob/master/doc/transactions/transaction.md#json-encoding-of-a-singlesignaturefulfillment
for an example of such an encoded public key. Technical details can be found on
https://godoc.org/github.com/threefoldtech/rivine/types#PublicKey
"""
scalar PublicKey
"""
Signature is the go-to type of this API for cryptographic signatures.
It is hex-encoded and can be seen by implementations of this API as a raw byte slice,
its content identified by the algorithm defined in the linked public key.
Please consult the documentation in the `PublicKey` type for more information about public keys
within the context of this API.
"""
scalar Signature
"""
BigInt represents an unbound integer type.
It is decimal (base 10) encoded as a string.
Within the context of this API it is used for currency values (coins and block stakes).
"""
scalar BigInt
"""
ByteVersion is a generic type, an unsigned 8-bit integer (equivalent to a single byte),
used for any place where we use such Versions.
Examples of such versions are `Transaction` and `UnlockCondition` versions.
"""
scalar ByteVersion

# TODO: replace txn implementations by Transaction interface once possible
#                   ... Same goes for AtomicSwapContract (Contract Union) and Wallets (Wallet Interface)

"""
Object represents an object that can be looked up by a unique identifier,
see ObjectID for more information about the identifier type used for objects.
See the used types in this union for more information about the possible objects.
"""
union Object = Block | StandardTransaction | MintConditionDefinitionTransaction | MintCoinCreationTransaction | MintCoinDestructionTransaction | AuthAddressUpdateTransaction | AuthConditionUpdateTransaction | Output | FreeForAllWallet | SingleSignatureWallet | MultiSignatureWallet | AtomicSwapContract

"""
Contract represents a contract object (also called smart contracts) that can be looked up by a unique identifier,
see UnlockHash for more information about the identifier type used for contracts.
See the used types in this union for more information about the possible contracts.
"""
union Contract = AtomicSwapContract

"""
ChainFacts collects facts about the queried chain.
"""
type ChainFacts {
    """
    Constants collects all constant (static) data known about the chain,
    and is provided by the daemon network configuration.
    """
    Constants: ChainConstants!
    """
    LastBlock allows you to look up the last block,
    saving you a second query, in case you need it, to look up that block,
    even if it is just the height or timestamp.
    """
    LastBlock: Block!
    """
    Contains all aggregated global data,
    updated for this chain for every applied and reverted block.
    """
    Aggregated: ChainAggregatedData
}

"""
ChainConstants collect all constant information known about
a chain network and exposed via this API.
"""
type ChainConstants {
    """
    The name of the chain that this explorer is connected to.
    """
    Name: String!
    """
    The name of the network,
    usually one of `"standard"`, `"testnet"`, "`devnet"`.
    The name of a network is not restricted to these values however.
    """
    NetworkName: String!
    """
    The unit of coins.
    For the Threefold Chain this is for example `"TFT"`.
    """
    CoinUnit: String!
    """
    The amount of decimals that the coins can be expressed in.
    The coin values are always exposed as the lowered unit,
    see the `BigInt` type for more information about the encoding
    within the context of this API.

    If for example the CoinPrecision is `2`,
    than a currency value of `"104"` is actually `1.04`.
    """
    CoinPecision: Int!
    """
    The source code version this daemon is compiled on.
    """
    ChainVersion: String!
    """
    The transaction version that clients should use as the default
    transaction version.
    """
    DefaultTransactionVersion: ByteVersion!
    """
    The gateway Protocol Version used by this daemon's gateway module.
    """
    GatewayProtocolVersion: String!
    """
    ConsensusPlugins provide you with the names of all plugins used by
    the consensus of this network's daemons and thus allows you to know
    what extra features might be available for this network.
    """
    ConsensusPlugins: [String!]
    """
    The (Unix Epoch, seconds) timestamp of the first block,
    the so called genesis block.
    """
    GenesisTimestamp: Timestamp!
    """
    Defines the maximum size a block is allowed to be, in bytes.
    """
    BlockSizeLimitInBytes: Int!
    """
    The average block creation time in seconds the consensus algorithm
    aims to achieve. It does not mean that it will take exatly this amount of seconds for a
    new block to be created, nor it is an upper limit. You will however notice that the average
    block creation time of a sufficient amount of sequential blocks does come close
    to this average block creation time.
    """
    AverageBlockCreationTimeInSeconds: Int!
    """
    The total amount of block stakes available at the creation of this blockchain.
    As blockchains can currently not create new block stakes it is also the final amount of block stakes on the chain.
    """
    GenesisTotalBlockStakes: BigInt!
    """
    Defines how many blocks a block stake have to age
    prior to being able to use block stakes for creating blocks.
    The age is calculated by computing the height when the stakes were
    transfered until the current block height.
    When transfering stakes to yourself as part of a block creation,
    the constant required aging concept (using the amount as defined here) does not apply.
    """
    BlockStakeAging: Int!
    """
    The fee that a block creator recieves for the creation of a block.
    Can be null in case the chain does not award fees for such creations,
    a possibility for private chains where all nodes are owned by one organisation.
    """
    BlockCreatorFee: BigInt
    """
    The minimum fee that has to be spent by a wallet in order to make a coin or block stake transfer.
    The fee does not apply for block creation transactions.
    Can be null in case the network does not require transaction fees.
    """
    MinimumTransactionFee: BigInt
    """
    Some networks collect all transaction fees in a single wallet,
    if this is the case it will be available as condition in this field, for query purposes.
    """
    TransactionFeeBeneficiary: UnlockCondition
    """
    This delay, in block amount, defines how long a miner payout (e.g. block creator or transaction fee)
    is locked prior to being spendable.
    """
    PayoutMaturityDelay: BlockHeight!
}

"""
The aggregated chain data,
updated for every block is that is applied and reverted.
"""
type ChainAggregatedData {
    TotalCoins: BigInt
    TotalLockedCoins: BigInt

    TotalBlockStakes: BigInt
    TotalLockedBlockStakes: BigInt
    EstimatedActiveBlockStakes: BigInt
}

"""
An inclusive range of block positions, with one or two points to be defined.
A range with no fields defined is equal to a nil range.
"""
input BlockPositionRange {
    Start: Int
    End: Int
}

"""
A poor man's input Union, allowing you to filter on block positions,
by defining what the upper- or lower limit is.
Or the inclusive range of blocks including and between (one or) two positions.
If no fields are given it is seen as a nil operator. No more then one field can be defined.

This really should be a Union, this is however not (yet) supported by the official GraphQL
specification. We probably will have to break this API later, as there is an active RFC working on supporting use cases like this.
"""
input BlockPositionOperators {
    Before: Int
    After: Int
    Between: BlockPositionRange
}

"""
An inclusive range of timestamps, with one or two points to be defined.
A range with no fields defined is equal to a nil range.
"""
input TimestampRange {
    Start: Timestamp
    End: Timestamp
}

"""
A poor man's input Union, allowing you to filter on timestamps,
by defining what the upper- or lower limit is.
Or the inclusive range of blocks including and between (one or) two timestamps.
If no fields are given it is seen as a nil operator. No more then one field can be defined.

This really should be a Union, this is however not (yet) supported by the official GraphQL
specification. We probably will have to break this API later, as there is an active RFC working on supporting use cases like this.
"""
input TimestampOperators {
    Before: Timestamp
    After: Timestamp
    Between: TimestampRange
}

"""
Filter based on an integer based on one of these options.

NOTE that these options should really be a Union, not an input composition type.
Once the RFC https://github.com/graphql/graphql-spec/blob/master/rfcs/InputUnion.md
is accepted and implemented by the implementations (including the one used by us),
we could use it here.
"""
input IntFilter {
    LessThan: Int
    LessThanOrEqualTo: Int
    EqualTo: Int
    GreaterThanOrEqualTo: Int
    GreaterThan: Int
}

"""
A hex-encoded MsgPack-based cursor,
allowing to continue a query from where
you started.
"""
scalar Cursor

"""
All possible filters that can be used to query for a list of blocks.
Multiple filters can be combined. It is also valid that none are given.
"""
# TODO: add transactionLengthFilter,
# using an int filter that works like a BigIntFilter
input BlocksFilter {
    Height: BlockPositionOperators
    Timestamp: TimestampOperators
    TransactionLength: IntFilter
    Limit: Int
    """
    A cursor that allows the blocks query to pick up from a state previously left off.
    When this cursor is defined, you should define the same filters as used last time,
    even though this is not enforced. The Limit filter is an exception to this.
    """
    Cursor: Cursor
}

"""
Response type for the blocks query.
"""
type ResponseBlocks {
    Blocks: [Block!]
    """
    In case all items could not be returned within a single call,
    this cursor can be used for a follow-up blocks query call.
    """
    NextCursor: Cursor
}

"""
Filter based on binary data based on one of these options.

NOTE that these options should really be a Union, not an input composition type.
Once the RFC https://github.com/graphql/graphql-spec/blob/master/rfcs/InputUnion.md
is accepted and implemented by the implementations (including the one used by us),
we could use it here.
"""
input BinaryDataFilter {
    StartsWith: BinaryData
    Contains: BinaryData
    EndsWith: BinaryData
    EqualTo: BinaryData
}

"""
Filter based on a big integer based on one of these options.

NOTE that these options should really be a Union, not an input composition type.
Once the RFC https://github.com/graphql/graphql-spec/blob/master/rfcs/InputUnion.md
is accepted and implemented by the implementations (including the one used by us),
we could use it here.
"""
input BigIntFilter {
    LessThan: BigInt
    LessThanOrEqualTo: BigInt
    EqualTo: BigInt
    GreaterThanOrEqualTo: BigInt
    GreaterThan: BigInt
}

"""
All possible filters that can be used to query for a list of transactions.
Multiple filters can be combined. It is also valid that none are given.
"""
input TransactionsFilter {
    Versions: [ByteVersion!]
    ArbitraryData: BinaryDataFilter
    CoinInputValue: BigIntFilter
    CoinOutputValue: BigIntFilter
}

"""
The API of the block's data view.
"""
type Block {
    """
    Data for this block,
    such as its Identifier, height and timestamp.
    """
    Header: BlockHeader!
    """
    Facts for this block such as its difficulty and target used,
    but also a snapshot of the aggregated chain data at the
    chain state on this block.

    Queried in a lazy manner, fetching only as much data as
    required for the query.
    """
    Facts: BlockFacts
    """
    The transactions part of this block.

    Queried in a lazy manner, fetching only as much data as
    required for the query.
    """
    Transactions(filter: TransactionsFilter): [Transaction!]
}

"""
The API of the facts collected for a block.
"""
type BlockFacts {
    """
    The difficulty used, in the consensus algorithm,
    for creating this block.
    """
    Difficulty: BigInt
    """
    The target hash used, in the consensus algorithm,
    for creating this block.
    """
    Target: Hash

    """
    The aggregated chain data as a snapshot taken,
    after this fact's block was applied.
    """
    ChainSnapshot: BlockChainSnapshotFacts
}

"""
The API of the chainshots facts collected for a block.
"""
type BlockChainSnapshotFacts {
    TotalCoins: BigInt
    TotalLockedCoins: BigInt
    TotalBlockStakes: BigInt
    TotalLockedBlockStakes: BigInt
    EstimatedActiveBlockStakes: BigInt
}

"""
The API for the block-specific "header" data of a block.
Containing information such as the ID, the ID of its parent block,
block time and height as well as (miner) payout information.
The Parent and Child block can be queried recursively as well.
"""
type BlockHeader {
    ID: Hash!
    ParentID: Hash
    Parent: Block
    Child: Block
    BlockTime: Timestamp
    BlockHeight: BlockHeight
    Payouts(type: BlockPayoutType): [BlockPayout!]
}

"""
The information about the created block that contains this transaction.
"""
type TransactionParentInfo {
    ID: Hash!
    ParentID: Hash
    Height: BlockHeight
    Timestamp: Timestamp
    """
    The static order (index) of this transaction
    as defined by the (parent) block that contains this transaction.
    """
    TransactionOrder: Int
    """
    All transactions found in the (parent) block,
    excluding this transaction.
    """
    SiblingTransactions(filter: TransactionsFilter): [Transaction!]
}

interface Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]

    ArbitraryData: BinaryData
}

"""
The standard transaction used for all regular transactions,
most commonly used for coin transfers and block creation transactions.
"""
type StandardTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    BlockStakeInputs: [Input!]
    BlockStakeOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

# TODO: add this using an extension-added appoach
"""
The transaction used to redefine the Minter condition,
defining "who" can mint (= create) new coins,
as well as who can redefine the Minter condition once this
transaction is applied.

As long as no MintConditionDefinitionTransaction has been created
the condition as defined in the network configuration,
the so called genesis Mint Condition, is used.

The currently active Minter condition (or the one active at a certain height)
cannot yet be queried with the GraphQL API.
"""
type MintConditionDefinitionTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    Nonce: BinaryData!

    #MintCondition: UnlockCondition # TODO: investigate if we can/want to expose the original (fulfilled) mint condition

    MintFulfillment: UnlockFulfillment!
    NewMintCondition: UnlockCondition!

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

# TODO: add this using an extension-added appoach
"""
The transaction used to mint tokens,
a transaction that can only be done by "who"
owns the currently active Minter condition.

See `MintConditionDefinitionTransaction` for more information.
"""
type MintCoinCreationTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    Nonce: BinaryData!

    #MintCondition: UnlockCondition  # TODO: investigate if we can/want to expose the fulfilled mint condition

    MintFulfillment: UnlockFulfillment!

    CoinInputs: [Input!]
    CoinOutputs: [Output!]!

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

# TODO: add this using an extension-added appoach
"""
A transaction that allows you to burn coins,
meaning that the value of the spent coin input(s)
are (partly) sent to no one. Or in other words,
the combined value sum of the fee payouts and coin outputs
will be smaller than the value sum of coin inputs.
"""
type MintCoinDestructionTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]!
    CoinOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

# TODO: add this using an extension-added appoach
"""
A transaction that allows the auth power to update
the authentication of an address.
"""
type AuthAddressUpdateTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    Nonce: BinaryData!
    AuthAddresses: [UnlockHashPublicKeyPair]
    DeauthAddresses: [UnlockHashPublicKeyPair]

    AuthFulfillment: UnlockFulfillment!

    FeePayouts: [TransactionFeePayout!]

    ArbitraryData: BinaryData
}

# TODO: add this using an extension-added appoach
"""
A transaction that allows the auth power to update
the condiiton, defining who is the auth power.
"""
type AuthConditionUpdateTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    Nonce: BinaryData!

    AuthFulfillment: UnlockFulfillment!
    NewAuthCondition: UnlockCondition!

    FeePayouts: [TransactionFeePayout!]

    ArbitraryData: BinaryData
}

"""
The different types of `Output` possible within the context of this API.
"""
enum OutputType {
	COIN
	BLOCK_STAKE
	BLOCK_CREATION_REWARD
	TRANSACTION_FEE
}

"""
Specific Output information for an `Output` used as `Input`
in a transaction. Within the context of this API
is this type only used for Transactions.

When looking up an `Output` it is always returned as the `Output`
type, optionally containing `ChildInput` in case it was also
used as an `Input` in some transaction already.
"""
type Input {
    ID: Hash!
    Type: OutputType
    Value: BigInt!
    Fulfillment: UnlockFulfillment!

    ParentOutput: Output
    ParentTransaction: Transaction
}

# TODO: replace txn implementations by Transaction interface once possible

"""
The different `Object` types that can contain an `Output`.
"""
union OutputParent = Block | StandardTransaction | MintConditionDefinitionTransaction | MintCoinCreationTransaction | MintCoinDestructionTransaction

"""
The API for an output, as queried directly or as a (sub) field of another query.
The `ChildInput` can be queried to know when (see the `Parent`) it was spent,
as well as who spent it (see the `Fulfillment` of the `ChildInput`).
"""
type Output {
    ID: Hash!
    Type: OutputType
    Value: BigInt!
    Condition: UnlockCondition!

    ChildInput: Input

    ParentID: Hash!
    Parent: OutputParent!
}

"""
The different types of Payouts one can find in a block (header).
"""
enum BlockPayoutType {
    BLOCK_REWARD
    TRANSACTION_FEE
}

type BlockPayout {
    Output: Output!
    Type: BlockPayoutType
}

type TransactionFeePayout {
    BlockPayout: BlockPayout
    Value: BigInt!
}


"""
Each `01` prefixed `UnlockHash` (wallet address) is linked to a `PublicKey`.
If it is known, and thus exposed on the chain at some point,
it will be stored, and can be queried using the `PublicKey` field.
That field will be `null` in case the `PublicKey` is not (yet) known.
"""
type UnlockHashPublicKeyPair {
    UnlockHash: UnlockHash!
    PublicKey: PublicKey
}

"""
An unlock condition is used to define "who"
can spent a coin or block stake output.

See the different `UnlockCondition` implementations
to kow the different conditions that are possible.
"""
interface UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash
}

type NilCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
}

type UnlockHashCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
    PublicKey: PublicKey
}

type AtomicSwapCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
    Sender: UnlockHashPublicKeyPair!
    Receiver: UnlockHashPublicKeyPair!
    HashedSecret: BinaryData!
    TimeLock: LockTime!
}

enum LockType {
    BLOCK_HEIGHT
    TIMESTAMP
}

type LockTimeCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash
    LockValue: LockTime!
    LockType: LockType!
    Condition: UnlockCondition!
}

type MultiSignatureCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
    Owners: [UnlockHashPublicKeyPair]!
    RequiredSignatureCount: Int!
}

interface UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
}

type SingleSignatureFulfillment implements UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
    PublicKey: PublicKey!
    Signature: Signature!
}

type AtomicSwapFulfillment implements UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
    PublicKey: PublicKey!
    Signature: Signature!
    Secret: BinaryData
}

type PublicKeySignaturePair {
    PublicKey: PublicKey!
    Signature: Signature!
}

type MultiSignatureFulfillment implements UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
    Pairs: [PublicKeySignaturePair!]!
}

"""
The balance contains aggregated asset values,
and is updated for each block that affect's a wallet's
coin or block stake balance.
"""
type Balance {
    Unlocked: BigInt!
    Locked: BigInt!
}

"""
A wallet is identified by an `UnlockHash` and can be sent
coins and block stakes to, as well as spent those
coins and block stakes received. In practise
it is nothing more than a storage of a private/public key pair
a public key which can be converted to (and exposed as) an UnlockHash
to look up its balance, in the case of a non-full client wallet.

See the Wallet implementations for the different wallets that are possible.
"""
interface Wallet {
    UnlockHash: UnlockHash!

    # TODO: support transactions and blocks in a paginated manner

    #Transactions: [Transaction!]
    #Blocks: [Block!]

    # TODO: support inputs and outputs in a paginated manner

    # Note: disabled for now, as we have no efficient way
    # of referencing them to a wallet at the moment
    # CoinOutputs: [Output!]
    # BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance
}

type FreeForAllWallet implements Wallet {
    UnlockHash: UnlockHash!

    # Note: disabled for now, as we have no efficient way
    # of referencing them to a wallet at the moment
    # CoinOutputs: [Output!]
    # BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance
}

type SingleSignatureWallet implements Wallet {
    UnlockHash: UnlockHash!

    # Note: disabled for now, as we have no efficient way
    # of referencing them to a wallet at the moment
    # CoinOutputs: [Output!]
    # BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance

    PublicKey: PublicKey
    MultiSignatureWallets: [MultiSignatureWallet!]
}

type MultiSignatureWallet implements Wallet {
    UnlockHash: UnlockHash!

    # Note: disabled for now, as we have no efficient way
    # of referencing them to a wallet at the moment
    # CoinOutputs: [Output!]
    # BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance

    Owners: [UnlockHashPublicKeyPair!]
    RequiredSignatureCount: Int
}

"""
A contract used by Rivine chains to start and complete an atomic swap.
See https://github.com/threefoldtech/rivine/blob/master/doc/atomicswap/atomicswap.md for more
information about atomic swaps.

In short it is in generally used to safely swap coins between two different blockchains,
without requiring trust in the other party.
"""
type AtomicSwapContract {
    UnlockHash: UnlockHash!

    ContractCondition: AtomicSwapCondition!
    ContractFulfillment: AtomicSwapFulfillment
    ContractValue: BigInt!

    Transactions: [Transaction!]

    CoinOutput: Output
}
