// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package explorergraphql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/threefoldtech/rivine/crypto"
	"github.com/threefoldtech/rivine/types"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Block() BlockResolver
	BlockHeader() BlockHeaderResolver
	MintCoinCreationTransaction() MintCoinCreationTransactionResolver
	MintCoinDestructionTransaction() MintCoinDestructionTransactionResolver
	MintConditionDefinitionTransaction() MintConditionDefinitionTransactionResolver
	Output() OutputResolver
	QueryRoot() QueryRootResolver
	StandardTransaction() StandardTransactionResolver
	TransactionFeePayout() TransactionFeePayoutResolver
	TransactionParentInfo() TransactionParentInfoResolver
	UnlockHashCondition() UnlockHashConditionResolver
	UnlockHashPublicKeyPair() UnlockHashPublicKeyPairResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AtomicSwapCondition struct {
		HashedSecret func(childComplexity int) int
		Receiver     func(childComplexity int) int
		Sender       func(childComplexity int) int
		TimeLock     func(childComplexity int) int
		UnlockHash   func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	AtomicSwapContract struct {
		BlockHeight         func(childComplexity int) int
		BlockTime           func(childComplexity int) int
		CoinInput           func(childComplexity int) int
		CoinOutput          func(childComplexity int) int
		ContractCondition   func(childComplexity int) int
		ContractFulfillment func(childComplexity int) int
		ContractValue       func(childComplexity int) int
		Transactions        func(childComplexity int) int
		UnlockHash          func(childComplexity int) int
	}

	AtomicSwapFulfillment struct {
		ParentCondition func(childComplexity int) int
		PublicKey       func(childComplexity int) int
		Secret          func(childComplexity int) int
		Signature       func(childComplexity int) int
		Version         func(childComplexity int) int
	}

	Balance struct {
		LastUpdateBlockHeight func(childComplexity int) int
		LastUpdateTimestamp   func(childComplexity int) int
		LastUpdateTransaction func(childComplexity int) int
		Locked                func(childComplexity int) int
		Unlocked              func(childComplexity int) int
	}

	Block struct {
		Header       func(childComplexity int) int
		Transactions func(childComplexity int) int
	}

	BlockHeader struct {
		BlockHeight func(childComplexity int) int
		BlockTime   func(childComplexity int) int
		ID          func(childComplexity int) int
		ParentID    func(childComplexity int) int
		Payouts     func(childComplexity int) int
	}

	BlockPayout struct {
		Output func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	Input struct {
		Fulfillment  func(childComplexity int) int
		ID           func(childComplexity int) int
		ParentOutput func(childComplexity int) int
		Type         func(childComplexity int) int
		Value        func(childComplexity int) int
	}

	LockTimeCondition struct {
		Condition  func(childComplexity int) int
		LockType   func(childComplexity int) int
		LockValue  func(childComplexity int) int
		UnlockHash func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	MintCoinCreationTransaction struct {
		ArbitraryData   func(childComplexity int) int
		CoinInputs      func(childComplexity int) int
		CoinOutputs     func(childComplexity int) int
		FeePayouts      func(childComplexity int) int
		ID              func(childComplexity int) int
		MintFulfillment func(childComplexity int) int
		Nonce           func(childComplexity int) int
		ParentBlock     func(childComplexity int) int
		Version         func(childComplexity int) int
	}

	MintCoinDestructionTransaction struct {
		ArbitraryData func(childComplexity int) int
		CoinInputs    func(childComplexity int) int
		CoinOutputs   func(childComplexity int) int
		FeePayouts    func(childComplexity int) int
		ID            func(childComplexity int) int
		ParentBlock   func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	MintConditionDefinitionTransaction struct {
		ArbitraryData    func(childComplexity int) int
		CoinInputs       func(childComplexity int) int
		CoinOutputs      func(childComplexity int) int
		FeePayouts       func(childComplexity int) int
		ID               func(childComplexity int) int
		MintFulfillment  func(childComplexity int) int
		NewMintCondition func(childComplexity int) int
		Nonce            func(childComplexity int) int
		ParentBlock      func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	MultiSignatureCondition struct {
		Owners                 func(childComplexity int) int
		RequiredSignatureCount func(childComplexity int) int
		UnlockHash             func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	MultiSignatureFulfillment struct {
		Pairs           func(childComplexity int) int
		ParentCondition func(childComplexity int) int
		Version         func(childComplexity int) int
	}

	MultiSignatureWallet struct {
		BlockHeight            func(childComplexity int) int
		BlockStakeBalance      func(childComplexity int) int
		BlockStakeInputs       func(childComplexity int) int
		BlockStakeOutputs      func(childComplexity int) int
		BlockTime              func(childComplexity int) int
		CoinBalance            func(childComplexity int) int
		CoinInputs             func(childComplexity int) int
		CoinOutputs            func(childComplexity int) int
		Owners                 func(childComplexity int) int
		RequiredSignatureCount func(childComplexity int) int
		Transactions           func(childComplexity int) int
		UnlockHash             func(childComplexity int) int
	}

	NilCondition struct {
		UnlockHash func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	Output struct {
		ChildInput func(childComplexity int) int
		Condition  func(childComplexity int) int
		ID         func(childComplexity int) int
		Parent     func(childComplexity int) int
		ParentID   func(childComplexity int) int
		Type       func(childComplexity int) int
		Value      func(childComplexity int) int
	}

	PublicKeySignaturePair struct {
		PublicKey func(childComplexity int) int
		Signature func(childComplexity int) int
	}

	QueryRoot struct {
		Block        func(childComplexity int, id *crypto.Hash, reference *ReferencePoint) int
		Blocks       func(childComplexity int, after *ReferencePoint, first *int, before *ReferencePoint, last *int) int
		Contract     func(childComplexity int, unlockhash types.UnlockHash) int
		Object       func(childComplexity int, id *ObjectID) int
		Output       func(childComplexity int, id crypto.Hash) int
		Transaction  func(childComplexity int, id crypto.Hash) int
		Transactions func(childComplexity int, after *ReferencePoint, first *int, before *ReferencePoint, last *int) int
		Wallet       func(childComplexity int, unlockhash types.UnlockHash) int
	}

	SingleSignatureFulfillment struct {
		ParentCondition func(childComplexity int) int
		PublicKey       func(childComplexity int) int
		Signature       func(childComplexity int) int
		Version         func(childComplexity int) int
	}

	SingleSignatureWallet struct {
		BlockHeight           func(childComplexity int) int
		BlockStakeBalance     func(childComplexity int) int
		BlockStakeInputs      func(childComplexity int) int
		BlockStakeOutputs     func(childComplexity int) int
		BlockTime             func(childComplexity int) int
		CoinBalance           func(childComplexity int) int
		CoinInputs            func(childComplexity int) int
		CoinOutputs           func(childComplexity int) int
		MultiSignatureWallets func(childComplexity int) int
		PublicKey             func(childComplexity int) int
		Transactions          func(childComplexity int) int
		UnlockHash            func(childComplexity int) int
	}

	StandardTransaction struct {
		ArbitraryData     func(childComplexity int) int
		BlockStakeInputs  func(childComplexity int) int
		BlockStakeOutputs func(childComplexity int) int
		CoinInputs        func(childComplexity int) int
		CoinOutputs       func(childComplexity int) int
		FeePayouts        func(childComplexity int) int
		ID                func(childComplexity int) int
		ParentBlock       func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	TransactionFeePayout struct {
		BlockPayout func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	TransactionParentInfo struct {
		Height              func(childComplexity int) int
		ID                  func(childComplexity int) int
		ParentID            func(childComplexity int) int
		SiblingTransactions func(childComplexity int) int
		Timestamp           func(childComplexity int) int
		TransactionOrder    func(childComplexity int) int
	}

	UnlockHashCondition struct {
		PublicKey  func(childComplexity int) int
		UnlockHash func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	UnlockHashPublicKeyPair struct {
		PublicKey  func(childComplexity int) int
		UnlockHash func(childComplexity int) int
	}
}

type BlockResolver interface {
	Transactions(ctx context.Context, obj *Block) ([]Transaction, error)
}
type BlockHeaderResolver interface {
	Payouts(ctx context.Context, obj *BlockHeader) ([]*BlockPayout, error)
}
type MintCoinCreationTransactionResolver interface {
	ParentBlock(ctx context.Context, obj *MintCoinCreationTransaction) (*TransactionParentInfo, error)

	CoinInputs(ctx context.Context, obj *MintCoinCreationTransaction) ([]*Input, error)
	CoinOutputs(ctx context.Context, obj *MintCoinCreationTransaction) ([]*Output, error)
}
type MintCoinDestructionTransactionResolver interface {
	ParentBlock(ctx context.Context, obj *MintCoinDestructionTransaction) (*TransactionParentInfo, error)
	CoinInputs(ctx context.Context, obj *MintCoinDestructionTransaction) ([]*Input, error)
	CoinOutputs(ctx context.Context, obj *MintCoinDestructionTransaction) ([]*Output, error)
}
type MintConditionDefinitionTransactionResolver interface {
	ParentBlock(ctx context.Context, obj *MintConditionDefinitionTransaction) (*TransactionParentInfo, error)

	CoinInputs(ctx context.Context, obj *MintConditionDefinitionTransaction) ([]*Input, error)
	CoinOutputs(ctx context.Context, obj *MintConditionDefinitionTransaction) ([]*Output, error)
}
type OutputResolver interface {
	Parent(ctx context.Context, obj *Output) (OutputParent, error)
}
type QueryRootResolver interface {
	Object(ctx context.Context, id *ObjectID) (Object, error)
	Block(ctx context.Context, id *crypto.Hash, reference *ReferencePoint) (*Block, error)
	Blocks(ctx context.Context, after *ReferencePoint, first *int, before *ReferencePoint, last *int) (Transaction, error)
	Transaction(ctx context.Context, id crypto.Hash) (Transaction, error)
	Transactions(ctx context.Context, after *ReferencePoint, first *int, before *ReferencePoint, last *int) (Transaction, error)
	Output(ctx context.Context, id crypto.Hash) (*Output, error)
	Wallet(ctx context.Context, unlockhash types.UnlockHash) (Wallet, error)
	Contract(ctx context.Context, unlockhash types.UnlockHash) (Contract, error)
}
type StandardTransactionResolver interface {
	ParentBlock(ctx context.Context, obj *StandardTransaction) (*TransactionParentInfo, error)
	CoinInputs(ctx context.Context, obj *StandardTransaction) ([]*Input, error)
	CoinOutputs(ctx context.Context, obj *StandardTransaction) ([]*Output, error)
	BlockStakeInputs(ctx context.Context, obj *StandardTransaction) ([]*Input, error)
	BlockStakeOutputs(ctx context.Context, obj *StandardTransaction) ([]*Output, error)
}
type TransactionFeePayoutResolver interface {
	BlockPayout(ctx context.Context, obj *TransactionFeePayout) (*BlockPayout, error)
}
type TransactionParentInfoResolver interface {
	SiblingTransactions(ctx context.Context, obj *TransactionParentInfo) ([]Transaction, error)
}
type UnlockHashConditionResolver interface {
	PublicKey(ctx context.Context, obj *UnlockHashCondition) (*types.PublicKey, error)
}
type UnlockHashPublicKeyPairResolver interface {
	PublicKey(ctx context.Context, obj *UnlockHashPublicKeyPair) (*types.PublicKey, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AtomicSwapCondition.HashedSecret":
		if e.complexity.AtomicSwapCondition.HashedSecret == nil {
			break
		}

		return e.complexity.AtomicSwapCondition.HashedSecret(childComplexity), true

	case "AtomicSwapCondition.Receiver":
		if e.complexity.AtomicSwapCondition.Receiver == nil {
			break
		}

		return e.complexity.AtomicSwapCondition.Receiver(childComplexity), true

	case "AtomicSwapCondition.Sender":
		if e.complexity.AtomicSwapCondition.Sender == nil {
			break
		}

		return e.complexity.AtomicSwapCondition.Sender(childComplexity), true

	case "AtomicSwapCondition.TimeLock":
		if e.complexity.AtomicSwapCondition.TimeLock == nil {
			break
		}

		return e.complexity.AtomicSwapCondition.TimeLock(childComplexity), true

	case "AtomicSwapCondition.UnlockHash":
		if e.complexity.AtomicSwapCondition.UnlockHash == nil {
			break
		}

		return e.complexity.AtomicSwapCondition.UnlockHash(childComplexity), true

	case "AtomicSwapCondition.Version":
		if e.complexity.AtomicSwapCondition.Version == nil {
			break
		}

		return e.complexity.AtomicSwapCondition.Version(childComplexity), true

	case "AtomicSwapContract.BlockHeight":
		if e.complexity.AtomicSwapContract.BlockHeight == nil {
			break
		}

		return e.complexity.AtomicSwapContract.BlockHeight(childComplexity), true

	case "AtomicSwapContract.BlockTime":
		if e.complexity.AtomicSwapContract.BlockTime == nil {
			break
		}

		return e.complexity.AtomicSwapContract.BlockTime(childComplexity), true

	case "AtomicSwapContract.CoinInput":
		if e.complexity.AtomicSwapContract.CoinInput == nil {
			break
		}

		return e.complexity.AtomicSwapContract.CoinInput(childComplexity), true

	case "AtomicSwapContract.CoinOutput":
		if e.complexity.AtomicSwapContract.CoinOutput == nil {
			break
		}

		return e.complexity.AtomicSwapContract.CoinOutput(childComplexity), true

	case "AtomicSwapContract.ContractCondition":
		if e.complexity.AtomicSwapContract.ContractCondition == nil {
			break
		}

		return e.complexity.AtomicSwapContract.ContractCondition(childComplexity), true

	case "AtomicSwapContract.ContractFulfillment":
		if e.complexity.AtomicSwapContract.ContractFulfillment == nil {
			break
		}

		return e.complexity.AtomicSwapContract.ContractFulfillment(childComplexity), true

	case "AtomicSwapContract.ContractValue":
		if e.complexity.AtomicSwapContract.ContractValue == nil {
			break
		}

		return e.complexity.AtomicSwapContract.ContractValue(childComplexity), true

	case "AtomicSwapContract.Transactions":
		if e.complexity.AtomicSwapContract.Transactions == nil {
			break
		}

		return e.complexity.AtomicSwapContract.Transactions(childComplexity), true

	case "AtomicSwapContract.UnlockHash":
		if e.complexity.AtomicSwapContract.UnlockHash == nil {
			break
		}

		return e.complexity.AtomicSwapContract.UnlockHash(childComplexity), true

	case "AtomicSwapFulfillment.ParentCondition":
		if e.complexity.AtomicSwapFulfillment.ParentCondition == nil {
			break
		}

		return e.complexity.AtomicSwapFulfillment.ParentCondition(childComplexity), true

	case "AtomicSwapFulfillment.PublicKey":
		if e.complexity.AtomicSwapFulfillment.PublicKey == nil {
			break
		}

		return e.complexity.AtomicSwapFulfillment.PublicKey(childComplexity), true

	case "AtomicSwapFulfillment.Secret":
		if e.complexity.AtomicSwapFulfillment.Secret == nil {
			break
		}

		return e.complexity.AtomicSwapFulfillment.Secret(childComplexity), true

	case "AtomicSwapFulfillment.Signature":
		if e.complexity.AtomicSwapFulfillment.Signature == nil {
			break
		}

		return e.complexity.AtomicSwapFulfillment.Signature(childComplexity), true

	case "AtomicSwapFulfillment.Version":
		if e.complexity.AtomicSwapFulfillment.Version == nil {
			break
		}

		return e.complexity.AtomicSwapFulfillment.Version(childComplexity), true

	case "Balance.LastUpdateBlockHeight":
		if e.complexity.Balance.LastUpdateBlockHeight == nil {
			break
		}

		return e.complexity.Balance.LastUpdateBlockHeight(childComplexity), true

	case "Balance.LastUpdateTimestamp":
		if e.complexity.Balance.LastUpdateTimestamp == nil {
			break
		}

		return e.complexity.Balance.LastUpdateTimestamp(childComplexity), true

	case "Balance.LastUpdateTransaction":
		if e.complexity.Balance.LastUpdateTransaction == nil {
			break
		}

		return e.complexity.Balance.LastUpdateTransaction(childComplexity), true

	case "Balance.Locked":
		if e.complexity.Balance.Locked == nil {
			break
		}

		return e.complexity.Balance.Locked(childComplexity), true

	case "Balance.Unlocked":
		if e.complexity.Balance.Unlocked == nil {
			break
		}

		return e.complexity.Balance.Unlocked(childComplexity), true

	case "Block.Header":
		if e.complexity.Block.Header == nil {
			break
		}

		return e.complexity.Block.Header(childComplexity), true

	case "Block.Transactions":
		if e.complexity.Block.Transactions == nil {
			break
		}

		return e.complexity.Block.Transactions(childComplexity), true

	case "BlockHeader.BlockHeight":
		if e.complexity.BlockHeader.BlockHeight == nil {
			break
		}

		return e.complexity.BlockHeader.BlockHeight(childComplexity), true

	case "BlockHeader.BlockTime":
		if e.complexity.BlockHeader.BlockTime == nil {
			break
		}

		return e.complexity.BlockHeader.BlockTime(childComplexity), true

	case "BlockHeader.ID":
		if e.complexity.BlockHeader.ID == nil {
			break
		}

		return e.complexity.BlockHeader.ID(childComplexity), true

	case "BlockHeader.ParentID":
		if e.complexity.BlockHeader.ParentID == nil {
			break
		}

		return e.complexity.BlockHeader.ParentID(childComplexity), true

	case "BlockHeader.Payouts":
		if e.complexity.BlockHeader.Payouts == nil {
			break
		}

		return e.complexity.BlockHeader.Payouts(childComplexity), true

	case "BlockPayout.Output":
		if e.complexity.BlockPayout.Output == nil {
			break
		}

		return e.complexity.BlockPayout.Output(childComplexity), true

	case "BlockPayout.Type":
		if e.complexity.BlockPayout.Type == nil {
			break
		}

		return e.complexity.BlockPayout.Type(childComplexity), true

	case "Input.Fulfillment":
		if e.complexity.Input.Fulfillment == nil {
			break
		}

		return e.complexity.Input.Fulfillment(childComplexity), true

	case "Input.ID":
		if e.complexity.Input.ID == nil {
			break
		}

		return e.complexity.Input.ID(childComplexity), true

	case "Input.ParentOutput":
		if e.complexity.Input.ParentOutput == nil {
			break
		}

		return e.complexity.Input.ParentOutput(childComplexity), true

	case "Input.Type":
		if e.complexity.Input.Type == nil {
			break
		}

		return e.complexity.Input.Type(childComplexity), true

	case "Input.Value":
		if e.complexity.Input.Value == nil {
			break
		}

		return e.complexity.Input.Value(childComplexity), true

	case "LockTimeCondition.Condition":
		if e.complexity.LockTimeCondition.Condition == nil {
			break
		}

		return e.complexity.LockTimeCondition.Condition(childComplexity), true

	case "LockTimeCondition.LockType":
		if e.complexity.LockTimeCondition.LockType == nil {
			break
		}

		return e.complexity.LockTimeCondition.LockType(childComplexity), true

	case "LockTimeCondition.LockValue":
		if e.complexity.LockTimeCondition.LockValue == nil {
			break
		}

		return e.complexity.LockTimeCondition.LockValue(childComplexity), true

	case "LockTimeCondition.UnlockHash":
		if e.complexity.LockTimeCondition.UnlockHash == nil {
			break
		}

		return e.complexity.LockTimeCondition.UnlockHash(childComplexity), true

	case "LockTimeCondition.Version":
		if e.complexity.LockTimeCondition.Version == nil {
			break
		}

		return e.complexity.LockTimeCondition.Version(childComplexity), true

	case "MintCoinCreationTransaction.ArbitraryData":
		if e.complexity.MintCoinCreationTransaction.ArbitraryData == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.ArbitraryData(childComplexity), true

	case "MintCoinCreationTransaction.CoinInputs":
		if e.complexity.MintCoinCreationTransaction.CoinInputs == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.CoinInputs(childComplexity), true

	case "MintCoinCreationTransaction.CoinOutputs":
		if e.complexity.MintCoinCreationTransaction.CoinOutputs == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.CoinOutputs(childComplexity), true

	case "MintCoinCreationTransaction.FeePayouts":
		if e.complexity.MintCoinCreationTransaction.FeePayouts == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.FeePayouts(childComplexity), true

	case "MintCoinCreationTransaction.ID":
		if e.complexity.MintCoinCreationTransaction.ID == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.ID(childComplexity), true

	case "MintCoinCreationTransaction.MintFulfillment":
		if e.complexity.MintCoinCreationTransaction.MintFulfillment == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.MintFulfillment(childComplexity), true

	case "MintCoinCreationTransaction.Nonce":
		if e.complexity.MintCoinCreationTransaction.Nonce == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.Nonce(childComplexity), true

	case "MintCoinCreationTransaction.ParentBlock":
		if e.complexity.MintCoinCreationTransaction.ParentBlock == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.ParentBlock(childComplexity), true

	case "MintCoinCreationTransaction.Version":
		if e.complexity.MintCoinCreationTransaction.Version == nil {
			break
		}

		return e.complexity.MintCoinCreationTransaction.Version(childComplexity), true

	case "MintCoinDestructionTransaction.ArbitraryData":
		if e.complexity.MintCoinDestructionTransaction.ArbitraryData == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.ArbitraryData(childComplexity), true

	case "MintCoinDestructionTransaction.CoinInputs":
		if e.complexity.MintCoinDestructionTransaction.CoinInputs == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.CoinInputs(childComplexity), true

	case "MintCoinDestructionTransaction.CoinOutputs":
		if e.complexity.MintCoinDestructionTransaction.CoinOutputs == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.CoinOutputs(childComplexity), true

	case "MintCoinDestructionTransaction.FeePayouts":
		if e.complexity.MintCoinDestructionTransaction.FeePayouts == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.FeePayouts(childComplexity), true

	case "MintCoinDestructionTransaction.ID":
		if e.complexity.MintCoinDestructionTransaction.ID == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.ID(childComplexity), true

	case "MintCoinDestructionTransaction.ParentBlock":
		if e.complexity.MintCoinDestructionTransaction.ParentBlock == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.ParentBlock(childComplexity), true

	case "MintCoinDestructionTransaction.Version":
		if e.complexity.MintCoinDestructionTransaction.Version == nil {
			break
		}

		return e.complexity.MintCoinDestructionTransaction.Version(childComplexity), true

	case "MintConditionDefinitionTransaction.ArbitraryData":
		if e.complexity.MintConditionDefinitionTransaction.ArbitraryData == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.ArbitraryData(childComplexity), true

	case "MintConditionDefinitionTransaction.CoinInputs":
		if e.complexity.MintConditionDefinitionTransaction.CoinInputs == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.CoinInputs(childComplexity), true

	case "MintConditionDefinitionTransaction.CoinOutputs":
		if e.complexity.MintConditionDefinitionTransaction.CoinOutputs == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.CoinOutputs(childComplexity), true

	case "MintConditionDefinitionTransaction.FeePayouts":
		if e.complexity.MintConditionDefinitionTransaction.FeePayouts == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.FeePayouts(childComplexity), true

	case "MintConditionDefinitionTransaction.ID":
		if e.complexity.MintConditionDefinitionTransaction.ID == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.ID(childComplexity), true

	case "MintConditionDefinitionTransaction.MintFulfillment":
		if e.complexity.MintConditionDefinitionTransaction.MintFulfillment == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.MintFulfillment(childComplexity), true

	case "MintConditionDefinitionTransaction.NewMintCondition":
		if e.complexity.MintConditionDefinitionTransaction.NewMintCondition == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.NewMintCondition(childComplexity), true

	case "MintConditionDefinitionTransaction.Nonce":
		if e.complexity.MintConditionDefinitionTransaction.Nonce == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.Nonce(childComplexity), true

	case "MintConditionDefinitionTransaction.ParentBlock":
		if e.complexity.MintConditionDefinitionTransaction.ParentBlock == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.ParentBlock(childComplexity), true

	case "MintConditionDefinitionTransaction.Version":
		if e.complexity.MintConditionDefinitionTransaction.Version == nil {
			break
		}

		return e.complexity.MintConditionDefinitionTransaction.Version(childComplexity), true

	case "MultiSignatureCondition.Owners":
		if e.complexity.MultiSignatureCondition.Owners == nil {
			break
		}

		return e.complexity.MultiSignatureCondition.Owners(childComplexity), true

	case "MultiSignatureCondition.RequiredSignatureCount":
		if e.complexity.MultiSignatureCondition.RequiredSignatureCount == nil {
			break
		}

		return e.complexity.MultiSignatureCondition.RequiredSignatureCount(childComplexity), true

	case "MultiSignatureCondition.UnlockHash":
		if e.complexity.MultiSignatureCondition.UnlockHash == nil {
			break
		}

		return e.complexity.MultiSignatureCondition.UnlockHash(childComplexity), true

	case "MultiSignatureCondition.Version":
		if e.complexity.MultiSignatureCondition.Version == nil {
			break
		}

		return e.complexity.MultiSignatureCondition.Version(childComplexity), true

	case "MultiSignatureFulfillment.Pairs":
		if e.complexity.MultiSignatureFulfillment.Pairs == nil {
			break
		}

		return e.complexity.MultiSignatureFulfillment.Pairs(childComplexity), true

	case "MultiSignatureFulfillment.ParentCondition":
		if e.complexity.MultiSignatureFulfillment.ParentCondition == nil {
			break
		}

		return e.complexity.MultiSignatureFulfillment.ParentCondition(childComplexity), true

	case "MultiSignatureFulfillment.Version":
		if e.complexity.MultiSignatureFulfillment.Version == nil {
			break
		}

		return e.complexity.MultiSignatureFulfillment.Version(childComplexity), true

	case "MultiSignatureWallet.BlockHeight":
		if e.complexity.MultiSignatureWallet.BlockHeight == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.BlockHeight(childComplexity), true

	case "MultiSignatureWallet.BlockStakeBalance":
		if e.complexity.MultiSignatureWallet.BlockStakeBalance == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.BlockStakeBalance(childComplexity), true

	case "MultiSignatureWallet.BlockStakeInputs":
		if e.complexity.MultiSignatureWallet.BlockStakeInputs == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.BlockStakeInputs(childComplexity), true

	case "MultiSignatureWallet.BlockStakeOutputs":
		if e.complexity.MultiSignatureWallet.BlockStakeOutputs == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.BlockStakeOutputs(childComplexity), true

	case "MultiSignatureWallet.BlockTime":
		if e.complexity.MultiSignatureWallet.BlockTime == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.BlockTime(childComplexity), true

	case "MultiSignatureWallet.CoinBalance":
		if e.complexity.MultiSignatureWallet.CoinBalance == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.CoinBalance(childComplexity), true

	case "MultiSignatureWallet.CoinInputs":
		if e.complexity.MultiSignatureWallet.CoinInputs == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.CoinInputs(childComplexity), true

	case "MultiSignatureWallet.CoinOutputs":
		if e.complexity.MultiSignatureWallet.CoinOutputs == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.CoinOutputs(childComplexity), true

	case "MultiSignatureWallet.Owners":
		if e.complexity.MultiSignatureWallet.Owners == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.Owners(childComplexity), true

	case "MultiSignatureWallet.RequiredSignatureCount":
		if e.complexity.MultiSignatureWallet.RequiredSignatureCount == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.RequiredSignatureCount(childComplexity), true

	case "MultiSignatureWallet.Transactions":
		if e.complexity.MultiSignatureWallet.Transactions == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.Transactions(childComplexity), true

	case "MultiSignatureWallet.UnlockHash":
		if e.complexity.MultiSignatureWallet.UnlockHash == nil {
			break
		}

		return e.complexity.MultiSignatureWallet.UnlockHash(childComplexity), true

	case "NilCondition.UnlockHash":
		if e.complexity.NilCondition.UnlockHash == nil {
			break
		}

		return e.complexity.NilCondition.UnlockHash(childComplexity), true

	case "NilCondition.Version":
		if e.complexity.NilCondition.Version == nil {
			break
		}

		return e.complexity.NilCondition.Version(childComplexity), true

	case "Output.ChildInput":
		if e.complexity.Output.ChildInput == nil {
			break
		}

		return e.complexity.Output.ChildInput(childComplexity), true

	case "Output.Condition":
		if e.complexity.Output.Condition == nil {
			break
		}

		return e.complexity.Output.Condition(childComplexity), true

	case "Output.ID":
		if e.complexity.Output.ID == nil {
			break
		}

		return e.complexity.Output.ID(childComplexity), true

	case "Output.Parent":
		if e.complexity.Output.Parent == nil {
			break
		}

		return e.complexity.Output.Parent(childComplexity), true

	case "Output.ParentID":
		if e.complexity.Output.ParentID == nil {
			break
		}

		return e.complexity.Output.ParentID(childComplexity), true

	case "Output.Type":
		if e.complexity.Output.Type == nil {
			break
		}

		return e.complexity.Output.Type(childComplexity), true

	case "Output.Value":
		if e.complexity.Output.Value == nil {
			break
		}

		return e.complexity.Output.Value(childComplexity), true

	case "PublicKeySignaturePair.PublicKey":
		if e.complexity.PublicKeySignaturePair.PublicKey == nil {
			break
		}

		return e.complexity.PublicKeySignaturePair.PublicKey(childComplexity), true

	case "PublicKeySignaturePair.Signature":
		if e.complexity.PublicKeySignaturePair.Signature == nil {
			break
		}

		return e.complexity.PublicKeySignaturePair.Signature(childComplexity), true

	case "QueryRoot.block":
		if e.complexity.QueryRoot.Block == nil {
			break
		}

		args, err := ec.field_QueryRoot_block_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Block(childComplexity, args["id"].(*crypto.Hash), args["reference"].(*ReferencePoint)), true

	case "QueryRoot.blocks":
		if e.complexity.QueryRoot.Blocks == nil {
			break
		}

		args, err := ec.field_QueryRoot_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Blocks(childComplexity, args["after"].(*ReferencePoint), args["first"].(*int), args["before"].(*ReferencePoint), args["last"].(*int)), true

	case "QueryRoot.contract":
		if e.complexity.QueryRoot.Contract == nil {
			break
		}

		args, err := ec.field_QueryRoot_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Contract(childComplexity, args["unlockhash"].(types.UnlockHash)), true

	case "QueryRoot.object":
		if e.complexity.QueryRoot.Object == nil {
			break
		}

		args, err := ec.field_QueryRoot_object_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Object(childComplexity, args["id"].(*ObjectID)), true

	case "QueryRoot.output":
		if e.complexity.QueryRoot.Output == nil {
			break
		}

		args, err := ec.field_QueryRoot_output_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Output(childComplexity, args["id"].(crypto.Hash)), true

	case "QueryRoot.transaction":
		if e.complexity.QueryRoot.Transaction == nil {
			break
		}

		args, err := ec.field_QueryRoot_transaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Transaction(childComplexity, args["id"].(crypto.Hash)), true

	case "QueryRoot.transactions":
		if e.complexity.QueryRoot.Transactions == nil {
			break
		}

		args, err := ec.field_QueryRoot_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Transactions(childComplexity, args["after"].(*ReferencePoint), args["first"].(*int), args["before"].(*ReferencePoint), args["last"].(*int)), true

	case "QueryRoot.wallet":
		if e.complexity.QueryRoot.Wallet == nil {
			break
		}

		args, err := ec.field_QueryRoot_wallet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.QueryRoot.Wallet(childComplexity, args["unlockhash"].(types.UnlockHash)), true

	case "SingleSignatureFulfillment.ParentCondition":
		if e.complexity.SingleSignatureFulfillment.ParentCondition == nil {
			break
		}

		return e.complexity.SingleSignatureFulfillment.ParentCondition(childComplexity), true

	case "SingleSignatureFulfillment.PublicKey":
		if e.complexity.SingleSignatureFulfillment.PublicKey == nil {
			break
		}

		return e.complexity.SingleSignatureFulfillment.PublicKey(childComplexity), true

	case "SingleSignatureFulfillment.Signature":
		if e.complexity.SingleSignatureFulfillment.Signature == nil {
			break
		}

		return e.complexity.SingleSignatureFulfillment.Signature(childComplexity), true

	case "SingleSignatureFulfillment.Version":
		if e.complexity.SingleSignatureFulfillment.Version == nil {
			break
		}

		return e.complexity.SingleSignatureFulfillment.Version(childComplexity), true

	case "SingleSignatureWallet.BlockHeight":
		if e.complexity.SingleSignatureWallet.BlockHeight == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.BlockHeight(childComplexity), true

	case "SingleSignatureWallet.BlockStakeBalance":
		if e.complexity.SingleSignatureWallet.BlockStakeBalance == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.BlockStakeBalance(childComplexity), true

	case "SingleSignatureWallet.BlockStakeInputs":
		if e.complexity.SingleSignatureWallet.BlockStakeInputs == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.BlockStakeInputs(childComplexity), true

	case "SingleSignatureWallet.BlockStakeOutputs":
		if e.complexity.SingleSignatureWallet.BlockStakeOutputs == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.BlockStakeOutputs(childComplexity), true

	case "SingleSignatureWallet.BlockTime":
		if e.complexity.SingleSignatureWallet.BlockTime == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.BlockTime(childComplexity), true

	case "SingleSignatureWallet.CoinBalance":
		if e.complexity.SingleSignatureWallet.CoinBalance == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.CoinBalance(childComplexity), true

	case "SingleSignatureWallet.CoinInputs":
		if e.complexity.SingleSignatureWallet.CoinInputs == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.CoinInputs(childComplexity), true

	case "SingleSignatureWallet.CoinOutputs":
		if e.complexity.SingleSignatureWallet.CoinOutputs == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.CoinOutputs(childComplexity), true

	case "SingleSignatureWallet.MultiSignatureWallets":
		if e.complexity.SingleSignatureWallet.MultiSignatureWallets == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.MultiSignatureWallets(childComplexity), true

	case "SingleSignatureWallet.PublicKey":
		if e.complexity.SingleSignatureWallet.PublicKey == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.PublicKey(childComplexity), true

	case "SingleSignatureWallet.Transactions":
		if e.complexity.SingleSignatureWallet.Transactions == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.Transactions(childComplexity), true

	case "SingleSignatureWallet.UnlockHash":
		if e.complexity.SingleSignatureWallet.UnlockHash == nil {
			break
		}

		return e.complexity.SingleSignatureWallet.UnlockHash(childComplexity), true

	case "StandardTransaction.ArbitraryData":
		if e.complexity.StandardTransaction.ArbitraryData == nil {
			break
		}

		return e.complexity.StandardTransaction.ArbitraryData(childComplexity), true

	case "StandardTransaction.BlockStakeInputs":
		if e.complexity.StandardTransaction.BlockStakeInputs == nil {
			break
		}

		return e.complexity.StandardTransaction.BlockStakeInputs(childComplexity), true

	case "StandardTransaction.BlockStakeOutputs":
		if e.complexity.StandardTransaction.BlockStakeOutputs == nil {
			break
		}

		return e.complexity.StandardTransaction.BlockStakeOutputs(childComplexity), true

	case "StandardTransaction.CoinInputs":
		if e.complexity.StandardTransaction.CoinInputs == nil {
			break
		}

		return e.complexity.StandardTransaction.CoinInputs(childComplexity), true

	case "StandardTransaction.CoinOutputs":
		if e.complexity.StandardTransaction.CoinOutputs == nil {
			break
		}

		return e.complexity.StandardTransaction.CoinOutputs(childComplexity), true

	case "StandardTransaction.FeePayouts":
		if e.complexity.StandardTransaction.FeePayouts == nil {
			break
		}

		return e.complexity.StandardTransaction.FeePayouts(childComplexity), true

	case "StandardTransaction.ID":
		if e.complexity.StandardTransaction.ID == nil {
			break
		}

		return e.complexity.StandardTransaction.ID(childComplexity), true

	case "StandardTransaction.ParentBlock":
		if e.complexity.StandardTransaction.ParentBlock == nil {
			break
		}

		return e.complexity.StandardTransaction.ParentBlock(childComplexity), true

	case "StandardTransaction.Version":
		if e.complexity.StandardTransaction.Version == nil {
			break
		}

		return e.complexity.StandardTransaction.Version(childComplexity), true

	case "TransactionFeePayout.BlockPayout":
		if e.complexity.TransactionFeePayout.BlockPayout == nil {
			break
		}

		return e.complexity.TransactionFeePayout.BlockPayout(childComplexity), true

	case "TransactionFeePayout.Value":
		if e.complexity.TransactionFeePayout.Value == nil {
			break
		}

		return e.complexity.TransactionFeePayout.Value(childComplexity), true

	case "TransactionParentInfo.Height":
		if e.complexity.TransactionParentInfo.Height == nil {
			break
		}

		return e.complexity.TransactionParentInfo.Height(childComplexity), true

	case "TransactionParentInfo.ID":
		if e.complexity.TransactionParentInfo.ID == nil {
			break
		}

		return e.complexity.TransactionParentInfo.ID(childComplexity), true

	case "TransactionParentInfo.ParentID":
		if e.complexity.TransactionParentInfo.ParentID == nil {
			break
		}

		return e.complexity.TransactionParentInfo.ParentID(childComplexity), true

	case "TransactionParentInfo.SiblingTransactions":
		if e.complexity.TransactionParentInfo.SiblingTransactions == nil {
			break
		}

		return e.complexity.TransactionParentInfo.SiblingTransactions(childComplexity), true

	case "TransactionParentInfo.Timestamp":
		if e.complexity.TransactionParentInfo.Timestamp == nil {
			break
		}

		return e.complexity.TransactionParentInfo.Timestamp(childComplexity), true

	case "TransactionParentInfo.TransactionOrder":
		if e.complexity.TransactionParentInfo.TransactionOrder == nil {
			break
		}

		return e.complexity.TransactionParentInfo.TransactionOrder(childComplexity), true

	case "UnlockHashCondition.PublicKey":
		if e.complexity.UnlockHashCondition.PublicKey == nil {
			break
		}

		return e.complexity.UnlockHashCondition.PublicKey(childComplexity), true

	case "UnlockHashCondition.UnlockHash":
		if e.complexity.UnlockHashCondition.UnlockHash == nil {
			break
		}

		return e.complexity.UnlockHashCondition.UnlockHash(childComplexity), true

	case "UnlockHashCondition.Version":
		if e.complexity.UnlockHashCondition.Version == nil {
			break
		}

		return e.complexity.UnlockHashCondition.Version(childComplexity), true

	case "UnlockHashPublicKeyPair.PublicKey":
		if e.complexity.UnlockHashPublicKeyPair.PublicKey == nil {
			break
		}

		return e.complexity.UnlockHashPublicKeyPair.PublicKey(childComplexity), true

	case "UnlockHashPublicKeyPair.UnlockHash":
		if e.complexity.UnlockHashPublicKeyPair.UnlockHash == nil {
			break
		}

		return e.complexity.UnlockHashPublicKeyPair.UnlockHash(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._QueryRoot(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	return graphql.ErrorResponse(ctx, "mutations are not supported")
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `schema {
    query: QueryRoot
}

# How to query transactions based on properties
# How to query wallets based on properties

# TODO: support querying of outputs

type QueryRoot {
  object(id: ObjectID): Object

  block(id: Hash, reference: ReferencePoint): Block
  blocks(after: ReferencePoint, first: Int, before: ReferencePoint, last: Int): Transaction

  transaction(id: Hash!): Transaction
  transactions(after: ReferencePoint, first: Int, before: ReferencePoint, last: Int): Transaction

  output(id: Hash!): Output

  wallet(unlockhash: UnlockHash!): Wallet
  contract(unlockhash: UnlockHash!): Contract
}

scalar ObjectID
scalar BlockHeight
scalar Timestamp
scalar ReferencePoint # BlockHeight or TimeStamp
scalar Hash
scalar UnlockHash
scalar LockTime
scalar BinaryData
scalar PublicKey
scalar Signature
scalar BigInt
scalar ByteVersion

union Object = Block | StandardTransaction | MintConditionDefinitionTransaction | MintCoinCreationTransaction | MintCoinDestructionTransaction | Output | SingleSignatureWallet | MultiSignatureWallet | AtomicSwapContract
union Contract = AtomicSwapContract

type Block {
    Header: BlockHeader!
    Transactions: [Transaction!]!
}

type BlockHeader {
    ID: Hash!
    ParentID: Hash
    BlockTime: Timestamp
    BlockHeight: BlockHeight
    Payouts: [BlockPayout!]
}

type TransactionParentInfo {
    ID: Hash!
    ParentID: Hash
    Height: BlockHeight
    Timestamp: Timestamp
    TransactionOrder: Int
    SiblingTransactions: [Transaction!]
}

interface Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]
    CoinOutputs: [Output!]
    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

type StandardTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    BlockStakeInputs: [Input!]
    BlockStakeOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

type MintConditionDefinitionTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    Nonce: BinaryData!
    #MintCondition: UnlockCondition
    MintFulfillment: UnlockFulfillment!
    NewMintCondition: UnlockCondition! # TODO: investigate if we can/want to expose the original (fulfilled) mint condition

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

type MintCoinCreationTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    Nonce: BinaryData!
    #MintCondition: UnlockCondition  # TODO: investigate if we can/want to expose the fulfilled mint condition
    MintFulfillment: UnlockFulfillment!

    CoinInputs: [Input!]
    CoinOutputs: [Output!]!

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

type MintCoinDestructionTransaction implements Transaction {
    ID: Hash!
    Version: ByteVersion!

    ParentBlock: TransactionParentInfo

    CoinInputs: [Input!]!
    CoinOutputs: [Output!]

    FeePayouts: [TransactionFeePayout!]
    ArbitraryData: BinaryData
}

enum OutputType {
	COIN
	BLOCK_STAKE
	BLOCK_CREATION_REWARD
	TRANSACTION_FEE
}

type Input {
    ID: Hash!
    Type: OutputType
    Value: BigInt!
    Fulfillment: UnlockFulfillment!

    ParentOutput: Output
}

# TODO: replace txn implementations by Transaction interface once possible
union OutputParent = Block | StandardTransaction | MintConditionDefinitionTransaction | MintCoinCreationTransaction | MintCoinDestructionTransaction

type Output {
    ID: Hash!
    Type: OutputType
    Value: BigInt!
    Condition: UnlockCondition!

    ChildInput: Input

    ParentID: Hash!
    Parent: OutputParent!
}

enum BlockPayoutType {
    BLOCK_REWARD
    TRANSACTION_FEE
}

type BlockPayout {
    Output: Output!
    Type: BlockPayoutType
}

type TransactionFeePayout {
    BlockPayout: BlockPayout
    Value: BigInt!
}

type UnlockHashPublicKeyPair {
    UnlockHash: UnlockHash!
    PublicKey: PublicKey
}

interface UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash
}

type NilCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
}

type UnlockHashCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
    PublicKey: PublicKey
}

type AtomicSwapCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
    Sender: UnlockHashPublicKeyPair!
    Receiver: UnlockHashPublicKeyPair!
    HashedSecret: BinaryData!
    TimeLock: LockTime!
}

enum LockType {
    BLOCK_HEIGHT
    TIMESTAMP
}

type LockTimeCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash
    LockValue: LockTime!
    LockType: LockType!
    Condition: UnlockCondition!
}

type MultiSignatureCondition implements UnlockCondition {
    Version: ByteVersion!
    UnlockHash: UnlockHash!
    Owners: [UnlockHashPublicKeyPair]!
    RequiredSignatureCount: Int!
}

interface UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
}

type SingleSignatureFulfillment implements UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
    PublicKey: PublicKey!
    Signature: Signature!
}

type AtomicSwapFulfillment implements UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
    PublicKey: PublicKey!
    Signature: Signature!
    Secret: BinaryData
}

type PublicKeySignaturePair {
    PublicKey: PublicKey!
    Signature: Signature!
}

type MultiSignatureFulfillment implements UnlockFulfillment {
    Version: ByteVersion!
    ParentCondition: UnlockCondition
    Pairs: [PublicKeySignaturePair!]!
}

type Balance {
    Unlocked: BigInt!
    Locked: BigInt!
    LastUpdateTimestamp: Timestamp!
    LastUpdateBlockHeight: BlockHeight!
    LastUpdateTransaction: Hash!
}

interface Wallet {
    UnlockHash: UnlockHash!

    BlockHeight: BlockHeight!
    BlockTime: Timestamp!

    Transactions: [Transaction!]

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    BlockStakeInputs: [Input!]
    BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance
}

type SingleSignatureWallet implements Wallet {
    UnlockHash: UnlockHash!

    PublicKey: PublicKey

    MultiSignatureWallets: [MultiSignatureWallet]

    BlockHeight: BlockHeight!
    BlockTime: Timestamp!

    Transactions: [Transaction!]

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    BlockStakeInputs: [Input!]
    BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance
}

type MultiSignatureWallet implements Wallet {
    UnlockHash: UnlockHash!

    Owners: [UnlockHashPublicKeyPair!]!
    RequiredSignatureCount: Int!

    BlockHeight: BlockHeight!
    BlockTime: Timestamp!

    Transactions: [Transaction!]

    CoinInputs: [Input!]
    CoinOutputs: [Output!]

    BlockStakeInputs: [Input!]
    BlockStakeOutputs: [Output!]

    CoinBalance: Balance
    BlockStakeBalance: Balance
}

type AtomicSwapContract {
    UnlockHash: UnlockHash!

    ContractCondition: AtomicSwapCondition!
    ContractFulfillment: AtomicSwapFulfillment
    ContractValue: BigInt!

    BlockHeight: BlockHeight!
    BlockTime: Timestamp!

    Transactions: [Transaction!]

    CoinInput: Input!
    CoinOutput: Output
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_QueryRoot___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_QueryRoot_block_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *crypto.Hash
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *ReferencePoint
	if tmp, ok := rawArgs["reference"]; ok {
		arg1, err = ec.unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reference"] = arg1
	return args, nil
}

func (ec *executionContext) field_QueryRoot_blocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ReferencePoint
	if tmp, ok := rawArgs["after"]; ok {
		arg0, err = ec.unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ReferencePoint
	if tmp, ok := rawArgs["before"]; ok {
		arg2, err = ec.unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_QueryRoot_contract_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UnlockHash
	if tmp, ok := rawArgs["unlockhash"]; ok {
		arg0, err = ec.unmarshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["unlockhash"] = arg0
	return args, nil
}

func (ec *executionContext) field_QueryRoot_object_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ObjectID
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOObjectID2githubcomthreefoldtechrivinemodulesexplorergraphqlObjectID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_QueryRoot_output_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 crypto.Hash
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_QueryRoot_transaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 crypto.Hash
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_QueryRoot_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ReferencePoint
	if tmp, ok := rawArgs["after"]; ok {
		arg0, err = ec.unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ReferencePoint
	if tmp, ok := rawArgs["before"]; ok {
		arg2, err = ec.unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_QueryRoot_wallet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UnlockHash
	if tmp, ok := rawArgs["unlockhash"]; ok {
		arg0, err = ec.unmarshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["unlockhash"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AtomicSwapCondition_Version(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapCondition_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapCondition_Sender(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UnlockHashPublicKeyPair)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapCondition_Receiver(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Receiver, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UnlockHashPublicKeyPair)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapCondition_HashedSecret(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HashedSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapCondition_TimeLock(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeLock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LockTime)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLockTime2githubcomthreefoldtechrivinemodulesexplorergraphqlLockTime(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_ContractCondition(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractCondition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*AtomicSwapCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAtomicSwapCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlAtomicSwapCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_ContractFulfillment(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractFulfillment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AtomicSwapFulfillment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAtomicSwapFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlAtomicSwapFulfillment(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_ContractValue(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BigInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_BlockHeight(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BlockHeight)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_BlockTime(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Timestamp)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_Transactions(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_CoinInput(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapContract_CoinOutput(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapContract) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapContract",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinOutput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapFulfillment_Version(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapFulfillment_ParentCondition(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentCondition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(UnlockCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapFulfillment_PublicKey(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.PublicKey)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapFulfillment_Signature(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Signature)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSignature2githubcomthreefoldtechrivinemodulesexplorergraphqlSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwapFulfillment_Secret(ctx context.Context, field graphql.CollectedField, obj *AtomicSwapFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwapFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_Unlocked(ctx context.Context, field graphql.CollectedField, obj *Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unlocked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BigInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_Locked(ctx context.Context, field graphql.CollectedField, obj *Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BigInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_LastUpdateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Timestamp)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_LastUpdateBlockHeight(ctx context.Context, field graphql.CollectedField, obj *Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateBlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BlockHeight)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_LastUpdateTransaction(ctx context.Context, field graphql.CollectedField, obj *Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_Header(ctx context.Context, field graphql.CollectedField, obj *Block) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Block",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Header, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BlockHeader)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBlockHeader2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockHeader(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_Transactions(ctx context.Context, field graphql.CollectedField, obj *Block) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Block",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Block().Transactions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockHeader_ID(ctx context.Context, field graphql.CollectedField, obj *BlockHeader) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockHeader",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockHeader_ParentID(ctx context.Context, field graphql.CollectedField, obj *BlockHeader) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockHeader",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockHeader_BlockTime(ctx context.Context, field graphql.CollectedField, obj *BlockHeader) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockHeader",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Timestamp)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockHeader_BlockHeight(ctx context.Context, field graphql.CollectedField, obj *BlockHeader) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockHeader",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.BlockHeight)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockHeader_Payouts(ctx context.Context, field graphql.CollectedField, obj *BlockHeader) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockHeader",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BlockHeader().Payouts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BlockPayout)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockPayout_Output(ctx context.Context, field graphql.CollectedField, obj *BlockPayout) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockPayout",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockPayout_Type(ctx context.Context, field graphql.CollectedField, obj *BlockPayout) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockPayout",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BlockPayoutType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlockPayoutType2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayoutType(ctx, field.Selections, res)
}

func (ec *executionContext) _Input_ID(ctx context.Context, field graphql.CollectedField, obj *Input) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Input",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _Input_Type(ctx context.Context, field graphql.CollectedField, obj *Input) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Input",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*OutputType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx, field.Selections, res)
}

func (ec *executionContext) _Input_Value(ctx context.Context, field graphql.CollectedField, obj *Input) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Input",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BigInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) _Input_Fulfillment(ctx context.Context, field graphql.CollectedField, obj *Input) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Input",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fulfillment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UnlockFulfillment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockFulfillment(ctx, field.Selections, res)
}

func (ec *executionContext) _Input_ParentOutput(ctx context.Context, field graphql.CollectedField, obj *Input) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Input",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentOutput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _LockTimeCondition_Version(ctx context.Context, field graphql.CollectedField, obj *LockTimeCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "LockTimeCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _LockTimeCondition_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *LockTimeCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "LockTimeCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _LockTimeCondition_LockValue(ctx context.Context, field graphql.CollectedField, obj *LockTimeCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "LockTimeCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LockTime)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLockTime2githubcomthreefoldtechrivinemodulesexplorergraphqlLockTime(ctx, field.Selections, res)
}

func (ec *executionContext) _LockTimeCondition_LockType(ctx context.Context, field graphql.CollectedField, obj *LockTimeCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "LockTimeCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(LockType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLockType2githubcomthreefoldtechrivinemodulesexplorergraphqlLockType(ctx, field.Selections, res)
}

func (ec *executionContext) _LockTimeCondition_Condition(ctx context.Context, field graphql.CollectedField, obj *LockTimeCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "LockTimeCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UnlockCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_ID(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_Version(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_ParentBlock(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintCoinCreationTransaction().ParentBlock(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TransactionParentInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionParentInfo2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionParentInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_Nonce(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_MintFulfillment(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MintFulfillment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UnlockFulfillment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockFulfillment(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_CoinInputs(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintCoinCreationTransaction().CoinInputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_CoinOutputs(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintCoinCreationTransaction().CoinOutputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_FeePayouts(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeePayouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TransactionFeePayout)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinCreationTransaction_ArbitraryData(ctx context.Context, field graphql.CollectedField, obj *MintCoinCreationTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinCreationTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArbitraryData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_ID(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_Version(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_ParentBlock(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintCoinDestructionTransaction().ParentBlock(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TransactionParentInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionParentInfo2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionParentInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_CoinInputs(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintCoinDestructionTransaction().CoinInputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_CoinOutputs(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintCoinDestructionTransaction().CoinOutputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_FeePayouts(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeePayouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TransactionFeePayout)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx, field.Selections, res)
}

func (ec *executionContext) _MintCoinDestructionTransaction_ArbitraryData(ctx context.Context, field graphql.CollectedField, obj *MintCoinDestructionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintCoinDestructionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArbitraryData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_ID(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_Version(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_ParentBlock(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintConditionDefinitionTransaction().ParentBlock(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TransactionParentInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionParentInfo2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionParentInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_Nonce(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_MintFulfillment(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MintFulfillment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UnlockFulfillment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockFulfillment(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_NewMintCondition(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewMintCondition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UnlockCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_CoinInputs(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintConditionDefinitionTransaction().CoinInputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_CoinOutputs(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MintConditionDefinitionTransaction().CoinOutputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_FeePayouts(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeePayouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TransactionFeePayout)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx, field.Selections, res)
}

func (ec *executionContext) _MintConditionDefinitionTransaction_ArbitraryData(ctx context.Context, field graphql.CollectedField, obj *MintConditionDefinitionTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MintConditionDefinitionTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArbitraryData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureCondition_Version(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureCondition_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureCondition_Owners(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*UnlockHashPublicKeyPair)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureCondition_RequiredSignatureCount(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredSignatureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureFulfillment_Version(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureFulfillment_ParentCondition(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentCondition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(UnlockCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureFulfillment_Pairs(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pairs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*PublicKeySignaturePair)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPublicKeySignaturePair2githubcomthreefoldtechrivinemodulesexplorergraphqlPublicKeySignaturePair(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_Owners(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*UnlockHashPublicKeyPair)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_RequiredSignatureCount(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredSignatureCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_BlockHeight(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BlockHeight)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_BlockTime(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Timestamp)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_Transactions(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_CoinInputs(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinInputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_CoinOutputs(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinOutputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_BlockStakeInputs(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStakeInputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_BlockStakeOutputs(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStakeOutputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_CoinBalance(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinBalance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Balance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBalance2githubcomthreefoldtechrivinemodulesexplorergraphqlBalance(ctx, field.Selections, res)
}

func (ec *executionContext) _MultiSignatureWallet_BlockStakeBalance(ctx context.Context, field graphql.CollectedField, obj *MultiSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MultiSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStakeBalance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Balance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBalance2githubcomthreefoldtechrivinemodulesexplorergraphqlBalance(ctx, field.Selections, res)
}

func (ec *executionContext) _NilCondition_Version(ctx context.Context, field graphql.CollectedField, obj *NilCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NilCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _NilCondition_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *NilCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NilCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_ID(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_Type(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*OutputType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_Value(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BigInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_Condition(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UnlockCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_ChildInput(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_ParentID(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _Output_Parent(ctx context.Context, field graphql.CollectedField, obj *Output) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Output",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Output().Parent(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(OutputParent)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOutputParent2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputParent(ctx, field.Selections, res)
}

func (ec *executionContext) _PublicKeySignaturePair_PublicKey(ctx context.Context, field graphql.CollectedField, obj *PublicKeySignaturePair) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PublicKeySignaturePair",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.PublicKey)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, field.Selections, res)
}

func (ec *executionContext) _PublicKeySignaturePair_Signature(ctx context.Context, field graphql.CollectedField, obj *PublicKeySignaturePair) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PublicKeySignaturePair",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Signature)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSignature2githubcomthreefoldtechrivinemodulesexplorergraphqlSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_object(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_object_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Object(rctx, args["id"].(*ObjectID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Object)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOObject2githubcomthreefoldtechrivinemodulesexplorergraphqlObject(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_block(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_block_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Block(rctx, args["id"].(*crypto.Hash), args["reference"].(*ReferencePoint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Block)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlock2githubcomthreefoldtechrivinemodulesexplorergraphqlBlock(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_blocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_blocks_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Blocks(rctx, args["after"].(*ReferencePoint), args["first"].(*int), args["before"].(*ReferencePoint), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_transaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_transaction_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Transaction(rctx, args["id"].(crypto.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_transactions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Transactions(rctx, args["after"].(*ReferencePoint), args["first"].(*int), args["before"].(*ReferencePoint), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_output(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_output_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Output(rctx, args["id"].(crypto.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_wallet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_wallet_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Wallet(rctx, args["unlockhash"].(types.UnlockHash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Wallet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlWallet(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot_contract(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot_contract_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryRoot().Contract(rctx, args["unlockhash"].(types.UnlockHash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Contract)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOContract2githubcomthreefoldtechrivinemodulesexplorergraphqlContract(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_QueryRoot___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _QueryRoot___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "QueryRoot",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureFulfillment_Version(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureFulfillment_ParentCondition(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentCondition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(UnlockCondition)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureFulfillment_PublicKey(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.PublicKey)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureFulfillment_Signature(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureFulfillment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureFulfillment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Signature)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSignature2githubcomthreefoldtechrivinemodulesexplorergraphqlSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_PublicKey(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.PublicKey)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_MultiSignatureWallets(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MultiSignatureWallets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*MultiSignatureWallet)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMultiSignatureWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlMultiSignatureWallet(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_BlockHeight(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BlockHeight)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_BlockTime(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Timestamp)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_Transactions(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_CoinInputs(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinInputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_CoinOutputs(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinOutputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_BlockStakeInputs(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStakeInputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_BlockStakeOutputs(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStakeOutputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_CoinBalance(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinBalance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Balance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBalance2githubcomthreefoldtechrivinemodulesexplorergraphqlBalance(ctx, field.Selections, res)
}

func (ec *executionContext) _SingleSignatureWallet_BlockStakeBalance(ctx context.Context, field graphql.CollectedField, obj *SingleSignatureWallet) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SingleSignatureWallet",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStakeBalance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Balance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBalance2githubcomthreefoldtechrivinemodulesexplorergraphqlBalance(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_ID(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_Version(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_ParentBlock(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StandardTransaction().ParentBlock(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TransactionParentInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionParentInfo2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionParentInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_CoinInputs(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StandardTransaction().CoinInputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_CoinOutputs(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StandardTransaction().CoinOutputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_BlockStakeInputs(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StandardTransaction().BlockStakeInputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Input)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_BlockStakeOutputs(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StandardTransaction().BlockStakeOutputs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Output)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_FeePayouts(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeePayouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TransactionFeePayout)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx, field.Selections, res)
}

func (ec *executionContext) _StandardTransaction_ArbitraryData(ctx context.Context, field graphql.CollectedField, obj *StandardTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StandardTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArbitraryData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BinaryData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionFeePayout_BlockPayout(ctx context.Context, field graphql.CollectedField, obj *TransactionFeePayout) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionFeePayout",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TransactionFeePayout().BlockPayout(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BlockPayout)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionFeePayout_Value(ctx context.Context, field graphql.CollectedField, obj *TransactionFeePayout) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionFeePayout",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BigInt)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionParentInfo_ID(ctx context.Context, field graphql.CollectedField, obj *TransactionParentInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionParentInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionParentInfo_ParentID(ctx context.Context, field graphql.CollectedField, obj *TransactionParentInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionParentInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*crypto.Hash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionParentInfo_Height(ctx context.Context, field graphql.CollectedField, obj *TransactionParentInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionParentInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.BlockHeight)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionParentInfo_Timestamp(ctx context.Context, field graphql.CollectedField, obj *TransactionParentInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionParentInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Timestamp)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionParentInfo_TransactionOrder(ctx context.Context, field graphql.CollectedField, obj *TransactionParentInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionParentInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionParentInfo_SiblingTransactions(ctx context.Context, field graphql.CollectedField, obj *TransactionParentInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TransactionParentInfo",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TransactionParentInfo().SiblingTransactions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _UnlockHashCondition_Version(ctx context.Context, field graphql.CollectedField, obj *UnlockHashCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UnlockHashCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ByteVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _UnlockHashCondition_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *UnlockHashCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UnlockHashCondition",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _UnlockHashCondition_PublicKey(ctx context.Context, field graphql.CollectedField, obj *UnlockHashCondition) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UnlockHashCondition",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnlockHashCondition().PublicKey(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.PublicKey)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, field.Selections, res)
}

func (ec *executionContext) _UnlockHashPublicKeyPair_UnlockHash(ctx context.Context, field graphql.CollectedField, obj *UnlockHashPublicKeyPair) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UnlockHashPublicKeyPair",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.UnlockHash)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, field.Selections, res)
}

func (ec *executionContext) _UnlockHashPublicKeyPair_PublicKey(ctx context.Context, field graphql.CollectedField, obj *UnlockHashPublicKeyPair) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UnlockHashPublicKeyPair",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnlockHashPublicKeyPair().PublicKey(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.PublicKey)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Contract(ctx context.Context, sel ast.SelectionSet, obj Contract) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case AtomicSwapContract:
		return ec._AtomicSwapContract(ctx, sel, &obj)
	case *AtomicSwapContract:
		return ec._AtomicSwapContract(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Object(ctx context.Context, sel ast.SelectionSet, obj Object) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Block:
		return ec._Block(ctx, sel, &obj)
	case *Block:
		return ec._Block(ctx, sel, obj)
	case StandardTransaction:
		return ec._StandardTransaction(ctx, sel, &obj)
	case *StandardTransaction:
		return ec._StandardTransaction(ctx, sel, obj)
	case MintConditionDefinitionTransaction:
		return ec._MintConditionDefinitionTransaction(ctx, sel, &obj)
	case *MintConditionDefinitionTransaction:
		return ec._MintConditionDefinitionTransaction(ctx, sel, obj)
	case MintCoinCreationTransaction:
		return ec._MintCoinCreationTransaction(ctx, sel, &obj)
	case *MintCoinCreationTransaction:
		return ec._MintCoinCreationTransaction(ctx, sel, obj)
	case MintCoinDestructionTransaction:
		return ec._MintCoinDestructionTransaction(ctx, sel, &obj)
	case *MintCoinDestructionTransaction:
		return ec._MintCoinDestructionTransaction(ctx, sel, obj)
	case Output:
		return ec._Output(ctx, sel, &obj)
	case *Output:
		return ec._Output(ctx, sel, obj)
	case SingleSignatureWallet:
		return ec._SingleSignatureWallet(ctx, sel, &obj)
	case *SingleSignatureWallet:
		return ec._SingleSignatureWallet(ctx, sel, obj)
	case MultiSignatureWallet:
		return ec._MultiSignatureWallet(ctx, sel, &obj)
	case *MultiSignatureWallet:
		return ec._MultiSignatureWallet(ctx, sel, obj)
	case AtomicSwapContract:
		return ec._AtomicSwapContract(ctx, sel, &obj)
	case *AtomicSwapContract:
		return ec._AtomicSwapContract(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _OutputParent(ctx context.Context, sel ast.SelectionSet, obj OutputParent) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Block:
		return ec._Block(ctx, sel, &obj)
	case *Block:
		return ec._Block(ctx, sel, obj)
	case StandardTransaction:
		return ec._StandardTransaction(ctx, sel, &obj)
	case *StandardTransaction:
		return ec._StandardTransaction(ctx, sel, obj)
	case MintConditionDefinitionTransaction:
		return ec._MintConditionDefinitionTransaction(ctx, sel, &obj)
	case *MintConditionDefinitionTransaction:
		return ec._MintConditionDefinitionTransaction(ctx, sel, obj)
	case MintCoinCreationTransaction:
		return ec._MintCoinCreationTransaction(ctx, sel, &obj)
	case *MintCoinCreationTransaction:
		return ec._MintCoinCreationTransaction(ctx, sel, obj)
	case MintCoinDestructionTransaction:
		return ec._MintCoinDestructionTransaction(ctx, sel, &obj)
	case *MintCoinDestructionTransaction:
		return ec._MintCoinDestructionTransaction(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj Transaction) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case StandardTransaction:
		return ec._StandardTransaction(ctx, sel, &obj)
	case *StandardTransaction:
		return ec._StandardTransaction(ctx, sel, obj)
	case MintConditionDefinitionTransaction:
		return ec._MintConditionDefinitionTransaction(ctx, sel, &obj)
	case *MintConditionDefinitionTransaction:
		return ec._MintConditionDefinitionTransaction(ctx, sel, obj)
	case MintCoinCreationTransaction:
		return ec._MintCoinCreationTransaction(ctx, sel, &obj)
	case *MintCoinCreationTransaction:
		return ec._MintCoinCreationTransaction(ctx, sel, obj)
	case MintCoinDestructionTransaction:
		return ec._MintCoinDestructionTransaction(ctx, sel, &obj)
	case *MintCoinDestructionTransaction:
		return ec._MintCoinDestructionTransaction(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UnlockCondition(ctx context.Context, sel ast.SelectionSet, obj UnlockCondition) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case NilCondition:
		return ec._NilCondition(ctx, sel, &obj)
	case *NilCondition:
		return ec._NilCondition(ctx, sel, obj)
	case UnlockHashCondition:
		return ec._UnlockHashCondition(ctx, sel, &obj)
	case *UnlockHashCondition:
		return ec._UnlockHashCondition(ctx, sel, obj)
	case AtomicSwapCondition:
		return ec._AtomicSwapCondition(ctx, sel, &obj)
	case *AtomicSwapCondition:
		return ec._AtomicSwapCondition(ctx, sel, obj)
	case LockTimeCondition:
		return ec._LockTimeCondition(ctx, sel, &obj)
	case *LockTimeCondition:
		return ec._LockTimeCondition(ctx, sel, obj)
	case MultiSignatureCondition:
		return ec._MultiSignatureCondition(ctx, sel, &obj)
	case *MultiSignatureCondition:
		return ec._MultiSignatureCondition(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UnlockFulfillment(ctx context.Context, sel ast.SelectionSet, obj UnlockFulfillment) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case SingleSignatureFulfillment:
		return ec._SingleSignatureFulfillment(ctx, sel, &obj)
	case *SingleSignatureFulfillment:
		return ec._SingleSignatureFulfillment(ctx, sel, obj)
	case AtomicSwapFulfillment:
		return ec._AtomicSwapFulfillment(ctx, sel, &obj)
	case *AtomicSwapFulfillment:
		return ec._AtomicSwapFulfillment(ctx, sel, obj)
	case MultiSignatureFulfillment:
		return ec._MultiSignatureFulfillment(ctx, sel, &obj)
	case *MultiSignatureFulfillment:
		return ec._MultiSignatureFulfillment(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Wallet(ctx context.Context, sel ast.SelectionSet, obj Wallet) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case SingleSignatureWallet:
		return ec._SingleSignatureWallet(ctx, sel, &obj)
	case *SingleSignatureWallet:
		return ec._SingleSignatureWallet(ctx, sel, obj)
	case MultiSignatureWallet:
		return ec._MultiSignatureWallet(ctx, sel, &obj)
	case *MultiSignatureWallet:
		return ec._MultiSignatureWallet(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var atomicSwapConditionImplementors = []string{"AtomicSwapCondition", "UnlockCondition"}

func (ec *executionContext) _AtomicSwapCondition(ctx context.Context, sel ast.SelectionSet, obj *AtomicSwapCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, atomicSwapConditionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AtomicSwapCondition")
		case "Version":
			out.Values[i] = ec._AtomicSwapCondition_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UnlockHash":
			out.Values[i] = ec._AtomicSwapCondition_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Sender":
			out.Values[i] = ec._AtomicSwapCondition_Sender(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Receiver":
			out.Values[i] = ec._AtomicSwapCondition_Receiver(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "HashedSecret":
			out.Values[i] = ec._AtomicSwapCondition_HashedSecret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "TimeLock":
			out.Values[i] = ec._AtomicSwapCondition_TimeLock(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var atomicSwapContractImplementors = []string{"AtomicSwapContract", "Object", "Contract"}

func (ec *executionContext) _AtomicSwapContract(ctx context.Context, sel ast.SelectionSet, obj *AtomicSwapContract) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, atomicSwapContractImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AtomicSwapContract")
		case "UnlockHash":
			out.Values[i] = ec._AtomicSwapContract_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ContractCondition":
			out.Values[i] = ec._AtomicSwapContract_ContractCondition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ContractFulfillment":
			out.Values[i] = ec._AtomicSwapContract_ContractFulfillment(ctx, field, obj)
		case "ContractValue":
			out.Values[i] = ec._AtomicSwapContract_ContractValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "BlockHeight":
			out.Values[i] = ec._AtomicSwapContract_BlockHeight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "BlockTime":
			out.Values[i] = ec._AtomicSwapContract_BlockTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Transactions":
			out.Values[i] = ec._AtomicSwapContract_Transactions(ctx, field, obj)
		case "CoinInput":
			out.Values[i] = ec._AtomicSwapContract_CoinInput(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CoinOutput":
			out.Values[i] = ec._AtomicSwapContract_CoinOutput(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var atomicSwapFulfillmentImplementors = []string{"AtomicSwapFulfillment", "UnlockFulfillment"}

func (ec *executionContext) _AtomicSwapFulfillment(ctx context.Context, sel ast.SelectionSet, obj *AtomicSwapFulfillment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, atomicSwapFulfillmentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AtomicSwapFulfillment")
		case "Version":
			out.Values[i] = ec._AtomicSwapFulfillment_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ParentCondition":
			out.Values[i] = ec._AtomicSwapFulfillment_ParentCondition(ctx, field, obj)
		case "PublicKey":
			out.Values[i] = ec._AtomicSwapFulfillment_PublicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Signature":
			out.Values[i] = ec._AtomicSwapFulfillment_Signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Secret":
			out.Values[i] = ec._AtomicSwapFulfillment_Secret(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var balanceImplementors = []string{"Balance"}

func (ec *executionContext) _Balance(ctx context.Context, sel ast.SelectionSet, obj *Balance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, balanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Balance")
		case "Unlocked":
			out.Values[i] = ec._Balance_Unlocked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Locked":
			out.Values[i] = ec._Balance_Locked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastUpdateTimestamp":
			out.Values[i] = ec._Balance_LastUpdateTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastUpdateBlockHeight":
			out.Values[i] = ec._Balance_LastUpdateBlockHeight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LastUpdateTransaction":
			out.Values[i] = ec._Balance_LastUpdateTransaction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockImplementors = []string{"Block", "Object", "OutputParent"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, blockImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "Header":
			out.Values[i] = ec._Block_Header(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Transactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Block_Transactions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockHeaderImplementors = []string{"BlockHeader"}

func (ec *executionContext) _BlockHeader(ctx context.Context, sel ast.SelectionSet, obj *BlockHeader) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, blockHeaderImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockHeader")
		case "ID":
			out.Values[i] = ec._BlockHeader_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentID":
			out.Values[i] = ec._BlockHeader_ParentID(ctx, field, obj)
		case "BlockTime":
			out.Values[i] = ec._BlockHeader_BlockTime(ctx, field, obj)
		case "BlockHeight":
			out.Values[i] = ec._BlockHeader_BlockHeight(ctx, field, obj)
		case "Payouts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BlockHeader_Payouts(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockPayoutImplementors = []string{"BlockPayout"}

func (ec *executionContext) _BlockPayout(ctx context.Context, sel ast.SelectionSet, obj *BlockPayout) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, blockPayoutImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockPayout")
		case "Output":
			out.Values[i] = ec._BlockPayout_Output(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Type":
			out.Values[i] = ec._BlockPayout_Type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputImplementors = []string{"Input"}

func (ec *executionContext) _Input(ctx context.Context, sel ast.SelectionSet, obj *Input) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, inputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Input")
		case "ID":
			out.Values[i] = ec._Input_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Type":
			out.Values[i] = ec._Input_Type(ctx, field, obj)
		case "Value":
			out.Values[i] = ec._Input_Value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Fulfillment":
			out.Values[i] = ec._Input_Fulfillment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ParentOutput":
			out.Values[i] = ec._Input_ParentOutput(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var lockTimeConditionImplementors = []string{"LockTimeCondition", "UnlockCondition"}

func (ec *executionContext) _LockTimeCondition(ctx context.Context, sel ast.SelectionSet, obj *LockTimeCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, lockTimeConditionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LockTimeCondition")
		case "Version":
			out.Values[i] = ec._LockTimeCondition_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UnlockHash":
			out.Values[i] = ec._LockTimeCondition_UnlockHash(ctx, field, obj)
		case "LockValue":
			out.Values[i] = ec._LockTimeCondition_LockValue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "LockType":
			out.Values[i] = ec._LockTimeCondition_LockType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Condition":
			out.Values[i] = ec._LockTimeCondition_Condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mintCoinCreationTransactionImplementors = []string{"MintCoinCreationTransaction", "Object", "Transaction", "OutputParent"}

func (ec *executionContext) _MintCoinCreationTransaction(ctx context.Context, sel ast.SelectionSet, obj *MintCoinCreationTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mintCoinCreationTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MintCoinCreationTransaction")
		case "ID":
			out.Values[i] = ec._MintCoinCreationTransaction_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Version":
			out.Values[i] = ec._MintCoinCreationTransaction_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentBlock":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintCoinCreationTransaction_ParentBlock(ctx, field, obj)
				return res
			})
		case "Nonce":
			out.Values[i] = ec._MintCoinCreationTransaction_Nonce(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "MintFulfillment":
			out.Values[i] = ec._MintCoinCreationTransaction_MintFulfillment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "CoinInputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintCoinCreationTransaction_CoinInputs(ctx, field, obj)
				return res
			})
		case "CoinOutputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintCoinCreationTransaction_CoinOutputs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "FeePayouts":
			out.Values[i] = ec._MintCoinCreationTransaction_FeePayouts(ctx, field, obj)
		case "ArbitraryData":
			out.Values[i] = ec._MintCoinCreationTransaction_ArbitraryData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mintCoinDestructionTransactionImplementors = []string{"MintCoinDestructionTransaction", "Object", "Transaction", "OutputParent"}

func (ec *executionContext) _MintCoinDestructionTransaction(ctx context.Context, sel ast.SelectionSet, obj *MintCoinDestructionTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mintCoinDestructionTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MintCoinDestructionTransaction")
		case "ID":
			out.Values[i] = ec._MintCoinDestructionTransaction_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Version":
			out.Values[i] = ec._MintCoinDestructionTransaction_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentBlock":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintCoinDestructionTransaction_ParentBlock(ctx, field, obj)
				return res
			})
		case "CoinInputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintCoinDestructionTransaction_CoinInputs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "CoinOutputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintCoinDestructionTransaction_CoinOutputs(ctx, field, obj)
				return res
			})
		case "FeePayouts":
			out.Values[i] = ec._MintCoinDestructionTransaction_FeePayouts(ctx, field, obj)
		case "ArbitraryData":
			out.Values[i] = ec._MintCoinDestructionTransaction_ArbitraryData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mintConditionDefinitionTransactionImplementors = []string{"MintConditionDefinitionTransaction", "Object", "Transaction", "OutputParent"}

func (ec *executionContext) _MintConditionDefinitionTransaction(ctx context.Context, sel ast.SelectionSet, obj *MintConditionDefinitionTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mintConditionDefinitionTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MintConditionDefinitionTransaction")
		case "ID":
			out.Values[i] = ec._MintConditionDefinitionTransaction_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Version":
			out.Values[i] = ec._MintConditionDefinitionTransaction_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentBlock":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintConditionDefinitionTransaction_ParentBlock(ctx, field, obj)
				return res
			})
		case "Nonce":
			out.Values[i] = ec._MintConditionDefinitionTransaction_Nonce(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "MintFulfillment":
			out.Values[i] = ec._MintConditionDefinitionTransaction_MintFulfillment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "NewMintCondition":
			out.Values[i] = ec._MintConditionDefinitionTransaction_NewMintCondition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "CoinInputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintConditionDefinitionTransaction_CoinInputs(ctx, field, obj)
				return res
			})
		case "CoinOutputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MintConditionDefinitionTransaction_CoinOutputs(ctx, field, obj)
				return res
			})
		case "FeePayouts":
			out.Values[i] = ec._MintConditionDefinitionTransaction_FeePayouts(ctx, field, obj)
		case "ArbitraryData":
			out.Values[i] = ec._MintConditionDefinitionTransaction_ArbitraryData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var multiSignatureConditionImplementors = []string{"MultiSignatureCondition", "UnlockCondition"}

func (ec *executionContext) _MultiSignatureCondition(ctx context.Context, sel ast.SelectionSet, obj *MultiSignatureCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, multiSignatureConditionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiSignatureCondition")
		case "Version":
			out.Values[i] = ec._MultiSignatureCondition_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UnlockHash":
			out.Values[i] = ec._MultiSignatureCondition_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Owners":
			out.Values[i] = ec._MultiSignatureCondition_Owners(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "RequiredSignatureCount":
			out.Values[i] = ec._MultiSignatureCondition_RequiredSignatureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var multiSignatureFulfillmentImplementors = []string{"MultiSignatureFulfillment", "UnlockFulfillment"}

func (ec *executionContext) _MultiSignatureFulfillment(ctx context.Context, sel ast.SelectionSet, obj *MultiSignatureFulfillment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, multiSignatureFulfillmentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiSignatureFulfillment")
		case "Version":
			out.Values[i] = ec._MultiSignatureFulfillment_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ParentCondition":
			out.Values[i] = ec._MultiSignatureFulfillment_ParentCondition(ctx, field, obj)
		case "Pairs":
			out.Values[i] = ec._MultiSignatureFulfillment_Pairs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var multiSignatureWalletImplementors = []string{"MultiSignatureWallet", "Object", "Wallet"}

func (ec *executionContext) _MultiSignatureWallet(ctx context.Context, sel ast.SelectionSet, obj *MultiSignatureWallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, multiSignatureWalletImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiSignatureWallet")
		case "UnlockHash":
			out.Values[i] = ec._MultiSignatureWallet_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Owners":
			out.Values[i] = ec._MultiSignatureWallet_Owners(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "RequiredSignatureCount":
			out.Values[i] = ec._MultiSignatureWallet_RequiredSignatureCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "BlockHeight":
			out.Values[i] = ec._MultiSignatureWallet_BlockHeight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "BlockTime":
			out.Values[i] = ec._MultiSignatureWallet_BlockTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Transactions":
			out.Values[i] = ec._MultiSignatureWallet_Transactions(ctx, field, obj)
		case "CoinInputs":
			out.Values[i] = ec._MultiSignatureWallet_CoinInputs(ctx, field, obj)
		case "CoinOutputs":
			out.Values[i] = ec._MultiSignatureWallet_CoinOutputs(ctx, field, obj)
		case "BlockStakeInputs":
			out.Values[i] = ec._MultiSignatureWallet_BlockStakeInputs(ctx, field, obj)
		case "BlockStakeOutputs":
			out.Values[i] = ec._MultiSignatureWallet_BlockStakeOutputs(ctx, field, obj)
		case "CoinBalance":
			out.Values[i] = ec._MultiSignatureWallet_CoinBalance(ctx, field, obj)
		case "BlockStakeBalance":
			out.Values[i] = ec._MultiSignatureWallet_BlockStakeBalance(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nilConditionImplementors = []string{"NilCondition", "UnlockCondition"}

func (ec *executionContext) _NilCondition(ctx context.Context, sel ast.SelectionSet, obj *NilCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, nilConditionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NilCondition")
		case "Version":
			out.Values[i] = ec._NilCondition_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UnlockHash":
			out.Values[i] = ec._NilCondition_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outputImplementors = []string{"Output", "Object"}

func (ec *executionContext) _Output(ctx context.Context, sel ast.SelectionSet, obj *Output) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, outputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Output")
		case "ID":
			out.Values[i] = ec._Output_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Type":
			out.Values[i] = ec._Output_Type(ctx, field, obj)
		case "Value":
			out.Values[i] = ec._Output_Value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Condition":
			out.Values[i] = ec._Output_Condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ChildInput":
			out.Values[i] = ec._Output_ChildInput(ctx, field, obj)
		case "ParentID":
			out.Values[i] = ec._Output_ParentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Parent":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Output_Parent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var publicKeySignaturePairImplementors = []string{"PublicKeySignaturePair"}

func (ec *executionContext) _PublicKeySignaturePair(ctx context.Context, sel ast.SelectionSet, obj *PublicKeySignaturePair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, publicKeySignaturePairImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicKeySignaturePair")
		case "PublicKey":
			out.Values[i] = ec._PublicKeySignaturePair_PublicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Signature":
			out.Values[i] = ec._PublicKeySignaturePair_Signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryRootImplementors = []string{"QueryRoot"}

func (ec *executionContext) _QueryRoot(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryRootImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "QueryRoot",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryRoot")
		case "object":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_object(ctx, field)
				return res
			})
		case "block":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_block(ctx, field)
				return res
			})
		case "blocks":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_blocks(ctx, field)
				return res
			})
		case "transaction":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_transaction(ctx, field)
				return res
			})
		case "transactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_transactions(ctx, field)
				return res
			})
		case "output":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_output(ctx, field)
				return res
			})
		case "wallet":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_wallet(ctx, field)
				return res
			})
		case "contract":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryRoot_contract(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._QueryRoot___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._QueryRoot___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var singleSignatureFulfillmentImplementors = []string{"SingleSignatureFulfillment", "UnlockFulfillment"}

func (ec *executionContext) _SingleSignatureFulfillment(ctx context.Context, sel ast.SelectionSet, obj *SingleSignatureFulfillment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, singleSignatureFulfillmentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleSignatureFulfillment")
		case "Version":
			out.Values[i] = ec._SingleSignatureFulfillment_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ParentCondition":
			out.Values[i] = ec._SingleSignatureFulfillment_ParentCondition(ctx, field, obj)
		case "PublicKey":
			out.Values[i] = ec._SingleSignatureFulfillment_PublicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Signature":
			out.Values[i] = ec._SingleSignatureFulfillment_Signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var singleSignatureWalletImplementors = []string{"SingleSignatureWallet", "Object", "Wallet"}

func (ec *executionContext) _SingleSignatureWallet(ctx context.Context, sel ast.SelectionSet, obj *SingleSignatureWallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, singleSignatureWalletImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleSignatureWallet")
		case "UnlockHash":
			out.Values[i] = ec._SingleSignatureWallet_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "PublicKey":
			out.Values[i] = ec._SingleSignatureWallet_PublicKey(ctx, field, obj)
		case "MultiSignatureWallets":
			out.Values[i] = ec._SingleSignatureWallet_MultiSignatureWallets(ctx, field, obj)
		case "BlockHeight":
			out.Values[i] = ec._SingleSignatureWallet_BlockHeight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "BlockTime":
			out.Values[i] = ec._SingleSignatureWallet_BlockTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Transactions":
			out.Values[i] = ec._SingleSignatureWallet_Transactions(ctx, field, obj)
		case "CoinInputs":
			out.Values[i] = ec._SingleSignatureWallet_CoinInputs(ctx, field, obj)
		case "CoinOutputs":
			out.Values[i] = ec._SingleSignatureWallet_CoinOutputs(ctx, field, obj)
		case "BlockStakeInputs":
			out.Values[i] = ec._SingleSignatureWallet_BlockStakeInputs(ctx, field, obj)
		case "BlockStakeOutputs":
			out.Values[i] = ec._SingleSignatureWallet_BlockStakeOutputs(ctx, field, obj)
		case "CoinBalance":
			out.Values[i] = ec._SingleSignatureWallet_CoinBalance(ctx, field, obj)
		case "BlockStakeBalance":
			out.Values[i] = ec._SingleSignatureWallet_BlockStakeBalance(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var standardTransactionImplementors = []string{"StandardTransaction", "Object", "Transaction", "OutputParent"}

func (ec *executionContext) _StandardTransaction(ctx context.Context, sel ast.SelectionSet, obj *StandardTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, standardTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StandardTransaction")
		case "ID":
			out.Values[i] = ec._StandardTransaction_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Version":
			out.Values[i] = ec._StandardTransaction_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentBlock":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StandardTransaction_ParentBlock(ctx, field, obj)
				return res
			})
		case "CoinInputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StandardTransaction_CoinInputs(ctx, field, obj)
				return res
			})
		case "CoinOutputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StandardTransaction_CoinOutputs(ctx, field, obj)
				return res
			})
		case "BlockStakeInputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StandardTransaction_BlockStakeInputs(ctx, field, obj)
				return res
			})
		case "BlockStakeOutputs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StandardTransaction_BlockStakeOutputs(ctx, field, obj)
				return res
			})
		case "FeePayouts":
			out.Values[i] = ec._StandardTransaction_FeePayouts(ctx, field, obj)
		case "ArbitraryData":
			out.Values[i] = ec._StandardTransaction_ArbitraryData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionFeePayoutImplementors = []string{"TransactionFeePayout"}

func (ec *executionContext) _TransactionFeePayout(ctx context.Context, sel ast.SelectionSet, obj *TransactionFeePayout) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, transactionFeePayoutImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionFeePayout")
		case "BlockPayout":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionFeePayout_BlockPayout(ctx, field, obj)
				return res
			})
		case "Value":
			out.Values[i] = ec._TransactionFeePayout_Value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionParentInfoImplementors = []string{"TransactionParentInfo"}

func (ec *executionContext) _TransactionParentInfo(ctx context.Context, sel ast.SelectionSet, obj *TransactionParentInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, transactionParentInfoImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionParentInfo")
		case "ID":
			out.Values[i] = ec._TransactionParentInfo_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentID":
			out.Values[i] = ec._TransactionParentInfo_ParentID(ctx, field, obj)
		case "Height":
			out.Values[i] = ec._TransactionParentInfo_Height(ctx, field, obj)
		case "Timestamp":
			out.Values[i] = ec._TransactionParentInfo_Timestamp(ctx, field, obj)
		case "TransactionOrder":
			out.Values[i] = ec._TransactionParentInfo_TransactionOrder(ctx, field, obj)
		case "SiblingTransactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionParentInfo_SiblingTransactions(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var unlockHashConditionImplementors = []string{"UnlockHashCondition", "UnlockCondition"}

func (ec *executionContext) _UnlockHashCondition(ctx context.Context, sel ast.SelectionSet, obj *UnlockHashCondition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, unlockHashConditionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnlockHashCondition")
		case "Version":
			out.Values[i] = ec._UnlockHashCondition_Version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "UnlockHash":
			out.Values[i] = ec._UnlockHashCondition_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "PublicKey":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnlockHashCondition_PublicKey(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var unlockHashPublicKeyPairImplementors = []string{"UnlockHashPublicKeyPair"}

func (ec *executionContext) _UnlockHashPublicKeyPair(ctx context.Context, sel ast.SelectionSet, obj *UnlockHashPublicKeyPair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, unlockHashPublicKeyPairImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnlockHashPublicKeyPair")
		case "UnlockHash":
			out.Values[i] = ec._UnlockHashPublicKeyPair_UnlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "PublicKey":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnlockHashPublicKeyPair_PublicKey(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAtomicSwapCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlAtomicSwapCondition(ctx context.Context, sel ast.SelectionSet, v AtomicSwapCondition) graphql.Marshaler {
	return ec._AtomicSwapCondition(ctx, sel, &v)
}

func (ec *executionContext) marshalNAtomicSwapCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlAtomicSwapCondition(ctx context.Context, sel ast.SelectionSet, v *AtomicSwapCondition) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AtomicSwapCondition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx context.Context, v interface{}) (BigInt, error) {
	var res BigInt
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNBigInt2githubcomthreefoldtechrivinemodulesexplorergraphqlBigInt(ctx context.Context, sel ast.SelectionSet, v BigInt) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx context.Context, v interface{}) (BinaryData, error) {
	var res BinaryData
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx context.Context, sel ast.SelectionSet, v BinaryData) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBlockHeader2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockHeader(ctx context.Context, sel ast.SelectionSet, v BlockHeader) graphql.Marshaler {
	return ec._BlockHeader(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlockHeader2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockHeader(ctx context.Context, sel ast.SelectionSet, v *BlockHeader) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._BlockHeader(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx context.Context, v interface{}) (types.BlockHeight, error) {
	return UnmarshalBlockHeight(v)
}

func (ec *executionContext) marshalNBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx context.Context, sel ast.SelectionSet, v types.BlockHeight) graphql.Marshaler {
	res := MarshalBlockHeight(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx context.Context, sel ast.SelectionSet, v BlockPayout) graphql.Marshaler {
	return ec._BlockPayout(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx context.Context, sel ast.SelectionSet, v *BlockPayout) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._BlockPayout(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx context.Context, v interface{}) (ByteVersion, error) {
	var res ByteVersion
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNByteVersion2githubcomthreefoldtechrivinemodulesexplorergraphqlByteVersion(ctx context.Context, sel ast.SelectionSet, v ByteVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx context.Context, v interface{}) (crypto.Hash, error) {
	return UnmarshalHash(v)
}

func (ec *executionContext) marshalNHash2githubcomthreefoldtechrivinecryptoHash(ctx context.Context, sel ast.SelectionSet, v crypto.Hash) graphql.Marshaler {
	res := MarshalHash(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx context.Context, sel ast.SelectionSet, v Input) graphql.Marshaler {
	return ec._Input(ctx, sel, &v)
}

func (ec *executionContext) marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx context.Context, sel ast.SelectionSet, v []*Input) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx context.Context, sel ast.SelectionSet, v *Input) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Input(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNLockTime2githubcomthreefoldtechrivinemodulesexplorergraphqlLockTime(ctx context.Context, v interface{}) (LockTime, error) {
	var res LockTime
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNLockTime2githubcomthreefoldtechrivinemodulesexplorergraphqlLockTime(ctx context.Context, sel ast.SelectionSet, v LockTime) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLockType2githubcomthreefoldtechrivinemodulesexplorergraphqlLockType(ctx context.Context, v interface{}) (LockType, error) {
	var res LockType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNLockType2githubcomthreefoldtechrivinemodulesexplorergraphqlLockType(ctx context.Context, sel ast.SelectionSet, v LockType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx context.Context, sel ast.SelectionSet, v Output) graphql.Marshaler {
	return ec._Output(ctx, sel, &v)
}

func (ec *executionContext) marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx context.Context, sel ast.SelectionSet, v []*Output) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx context.Context, sel ast.SelectionSet, v *Output) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Output(ctx, sel, v)
}

func (ec *executionContext) marshalNOutputParent2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputParent(ctx context.Context, sel ast.SelectionSet, v OutputParent) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OutputParent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx context.Context, v interface{}) (types.PublicKey, error) {
	return UnmarshalPublicKey(v)
}

func (ec *executionContext) marshalNPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx context.Context, sel ast.SelectionSet, v types.PublicKey) graphql.Marshaler {
	res := MarshalPublicKey(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNPublicKeySignaturePair2githubcomthreefoldtechrivinemodulesexplorergraphqlPublicKeySignaturePair(ctx context.Context, sel ast.SelectionSet, v PublicKeySignaturePair) graphql.Marshaler {
	return ec._PublicKeySignaturePair(ctx, sel, &v)
}

func (ec *executionContext) marshalNPublicKeySignaturePair2githubcomthreefoldtechrivinemodulesexplorergraphqlPublicKeySignaturePair(ctx context.Context, sel ast.SelectionSet, v []*PublicKeySignaturePair) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublicKeySignaturePair2githubcomthreefoldtechrivinemodulesexplorergraphqlPublicKeySignaturePair(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPublicKeySignaturePair2githubcomthreefoldtechrivinemodulesexplorergraphqlPublicKeySignaturePair(ctx context.Context, sel ast.SelectionSet, v *PublicKeySignaturePair) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PublicKeySignaturePair(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSignature2githubcomthreefoldtechrivinemodulesexplorergraphqlSignature(ctx context.Context, v interface{}) (Signature, error) {
	var res Signature
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNSignature2githubcomthreefoldtechrivinemodulesexplorergraphqlSignature(ctx context.Context, sel ast.SelectionSet, v Signature) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx context.Context, v interface{}) (types.Timestamp, error) {
	return UnmarshalTimestamp(v)
}

func (ec *executionContext) marshalNTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx context.Context, sel ast.SelectionSet, v types.Timestamp) graphql.Marshaler {
	res := MarshalTimestamp(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx context.Context, sel ast.SelectionSet, v Transaction) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx context.Context, sel ast.SelectionSet, v []Transaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx context.Context, sel ast.SelectionSet, v TransactionFeePayout) graphql.Marshaler {
	return ec._TransactionFeePayout(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx context.Context, sel ast.SelectionSet, v *TransactionFeePayout) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TransactionFeePayout(ctx, sel, v)
}

func (ec *executionContext) marshalNUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx context.Context, sel ast.SelectionSet, v UnlockCondition) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._UnlockCondition(ctx, sel, v)
}

func (ec *executionContext) marshalNUnlockFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockFulfillment(ctx context.Context, sel ast.SelectionSet, v UnlockFulfillment) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._UnlockFulfillment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx context.Context, v interface{}) (types.UnlockHash, error) {
	return UnmarshalUnlockHash(v)
}

func (ec *executionContext) marshalNUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx context.Context, sel ast.SelectionSet, v types.UnlockHash) graphql.Marshaler {
	res := MarshalUnlockHash(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx context.Context, sel ast.SelectionSet, v UnlockHashPublicKeyPair) graphql.Marshaler {
	return ec._UnlockHashPublicKeyPair(ctx, sel, &v)
}

func (ec *executionContext) marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx context.Context, sel ast.SelectionSet, v []*UnlockHashPublicKeyPair) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx context.Context, sel ast.SelectionSet, v *UnlockHashPublicKeyPair) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._UnlockHashPublicKeyPair(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAtomicSwapFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlAtomicSwapFulfillment(ctx context.Context, sel ast.SelectionSet, v AtomicSwapFulfillment) graphql.Marshaler {
	return ec._AtomicSwapFulfillment(ctx, sel, &v)
}

func (ec *executionContext) marshalOAtomicSwapFulfillment2githubcomthreefoldtechrivinemodulesexplorergraphqlAtomicSwapFulfillment(ctx context.Context, sel ast.SelectionSet, v *AtomicSwapFulfillment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AtomicSwapFulfillment(ctx, sel, v)
}

func (ec *executionContext) marshalOBalance2githubcomthreefoldtechrivinemodulesexplorergraphqlBalance(ctx context.Context, sel ast.SelectionSet, v Balance) graphql.Marshaler {
	return ec._Balance(ctx, sel, &v)
}

func (ec *executionContext) marshalOBalance2githubcomthreefoldtechrivinemodulesexplorergraphqlBalance(ctx context.Context, sel ast.SelectionSet, v *Balance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Balance(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx context.Context, v interface{}) (BinaryData, error) {
	var res BinaryData
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx context.Context, sel ast.SelectionSet, v BinaryData) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx context.Context, v interface{}) (*BinaryData, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBinaryData2githubcomthreefoldtechrivinemodulesexplorergraphqlBinaryData(ctx context.Context, sel ast.SelectionSet, v *BinaryData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBlock2githubcomthreefoldtechrivinemodulesexplorergraphqlBlock(ctx context.Context, sel ast.SelectionSet, v Block) graphql.Marshaler {
	return ec._Block(ctx, sel, &v)
}

func (ec *executionContext) marshalOBlock2githubcomthreefoldtechrivinemodulesexplorergraphqlBlock(ctx context.Context, sel ast.SelectionSet, v *Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx context.Context, v interface{}) (types.BlockHeight, error) {
	return UnmarshalBlockHeight(v)
}

func (ec *executionContext) marshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx context.Context, sel ast.SelectionSet, v types.BlockHeight) graphql.Marshaler {
	return MarshalBlockHeight(v)
}

func (ec *executionContext) unmarshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx context.Context, v interface{}) (*types.BlockHeight, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx context.Context, sel ast.SelectionSet, v *types.BlockHeight) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBlockHeight2githubcomthreefoldtechrivinetypesBlockHeight(ctx, sel, *v)
}

func (ec *executionContext) marshalOBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx context.Context, sel ast.SelectionSet, v BlockPayout) graphql.Marshaler {
	return ec._BlockPayout(ctx, sel, &v)
}

func (ec *executionContext) marshalOBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx context.Context, sel ast.SelectionSet, v []*BlockPayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOBlockPayout2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayout(ctx context.Context, sel ast.SelectionSet, v *BlockPayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockPayout(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBlockPayoutType2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayoutType(ctx context.Context, v interface{}) (BlockPayoutType, error) {
	var res BlockPayoutType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBlockPayoutType2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayoutType(ctx context.Context, sel ast.SelectionSet, v BlockPayoutType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBlockPayoutType2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayoutType(ctx context.Context, v interface{}) (*BlockPayoutType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBlockPayoutType2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayoutType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBlockPayoutType2githubcomthreefoldtechrivinemodulesexplorergraphqlBlockPayoutType(ctx context.Context, sel ast.SelectionSet, v *BlockPayoutType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOContract2githubcomthreefoldtechrivinemodulesexplorergraphqlContract(ctx context.Context, sel ast.SelectionSet, v Contract) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Contract(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx context.Context, v interface{}) (crypto.Hash, error) {
	return UnmarshalHash(v)
}

func (ec *executionContext) marshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx context.Context, sel ast.SelectionSet, v crypto.Hash) graphql.Marshaler {
	return MarshalHash(v)
}

func (ec *executionContext) unmarshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx context.Context, v interface{}) (*crypto.Hash, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx context.Context, sel ast.SelectionSet, v *crypto.Hash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOHash2githubcomthreefoldtechrivinecryptoHash(ctx, sel, *v)
}

func (ec *executionContext) marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx context.Context, sel ast.SelectionSet, v Input) graphql.Marshaler {
	return ec._Input(ctx, sel, &v)
}

func (ec *executionContext) marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx context.Context, sel ast.SelectionSet, v []*Input) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInput2githubcomthreefoldtechrivinemodulesexplorergraphqlInput(ctx context.Context, sel ast.SelectionSet, v *Input) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Input(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOMultiSignatureWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlMultiSignatureWallet(ctx context.Context, sel ast.SelectionSet, v MultiSignatureWallet) graphql.Marshaler {
	return ec._MultiSignatureWallet(ctx, sel, &v)
}

func (ec *executionContext) marshalOMultiSignatureWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlMultiSignatureWallet(ctx context.Context, sel ast.SelectionSet, v []*MultiSignatureWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMultiSignatureWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlMultiSignatureWallet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMultiSignatureWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlMultiSignatureWallet(ctx context.Context, sel ast.SelectionSet, v *MultiSignatureWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MultiSignatureWallet(ctx, sel, v)
}

func (ec *executionContext) marshalOObject2githubcomthreefoldtechrivinemodulesexplorergraphqlObject(ctx context.Context, sel ast.SelectionSet, v Object) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Object(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObjectID2githubcomthreefoldtechrivinemodulesexplorergraphqlObjectID(ctx context.Context, v interface{}) (ObjectID, error) {
	var res ObjectID
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOObjectID2githubcomthreefoldtechrivinemodulesexplorergraphqlObjectID(ctx context.Context, sel ast.SelectionSet, v ObjectID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOObjectID2githubcomthreefoldtechrivinemodulesexplorergraphqlObjectID(ctx context.Context, v interface{}) (*ObjectID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOObjectID2githubcomthreefoldtechrivinemodulesexplorergraphqlObjectID(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOObjectID2githubcomthreefoldtechrivinemodulesexplorergraphqlObjectID(ctx context.Context, sel ast.SelectionSet, v *ObjectID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx context.Context, sel ast.SelectionSet, v Output) graphql.Marshaler {
	return ec._Output(ctx, sel, &v)
}

func (ec *executionContext) marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx context.Context, sel ast.SelectionSet, v []*Output) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOOutput2githubcomthreefoldtechrivinemodulesexplorergraphqlOutput(ctx context.Context, sel ast.SelectionSet, v *Output) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Output(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx context.Context, v interface{}) (OutputType, error) {
	var res OutputType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx context.Context, sel ast.SelectionSet, v OutputType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx context.Context, v interface{}) (*OutputType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOOutputType2githubcomthreefoldtechrivinemodulesexplorergraphqlOutputType(ctx context.Context, sel ast.SelectionSet, v *OutputType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx context.Context, v interface{}) (types.PublicKey, error) {
	return UnmarshalPublicKey(v)
}

func (ec *executionContext) marshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx context.Context, sel ast.SelectionSet, v types.PublicKey) graphql.Marshaler {
	return MarshalPublicKey(v)
}

func (ec *executionContext) unmarshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx context.Context, v interface{}) (*types.PublicKey, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx context.Context, sel ast.SelectionSet, v *types.PublicKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOPublicKey2githubcomthreefoldtechrivinetypesPublicKey(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx context.Context, v interface{}) (ReferencePoint, error) {
	var res ReferencePoint
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx context.Context, sel ast.SelectionSet, v ReferencePoint) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx context.Context, v interface{}) (*ReferencePoint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOReferencePoint2githubcomthreefoldtechrivinemodulesexplorergraphqlReferencePoint(ctx context.Context, sel ast.SelectionSet, v *ReferencePoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx context.Context, v interface{}) (types.Timestamp, error) {
	return UnmarshalTimestamp(v)
}

func (ec *executionContext) marshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx context.Context, sel ast.SelectionSet, v types.Timestamp) graphql.Marshaler {
	return MarshalTimestamp(v)
}

func (ec *executionContext) unmarshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx context.Context, v interface{}) (*types.Timestamp, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx context.Context, sel ast.SelectionSet, v *types.Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTimestamp2githubcomthreefoldtechrivinetypesTimestamp(ctx, sel, *v)
}

func (ec *executionContext) marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx context.Context, sel ast.SelectionSet, v Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalOTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx context.Context, sel ast.SelectionSet, v []Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2githubcomthreefoldtechrivinemodulesexplorergraphqlTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx context.Context, sel ast.SelectionSet, v []*TransactionFeePayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionFeePayout2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionFeePayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTransactionParentInfo2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionParentInfo(ctx context.Context, sel ast.SelectionSet, v TransactionParentInfo) graphql.Marshaler {
	return ec._TransactionParentInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalOTransactionParentInfo2githubcomthreefoldtechrivinemodulesexplorergraphqlTransactionParentInfo(ctx context.Context, sel ast.SelectionSet, v *TransactionParentInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionParentInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOUnlockCondition2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockCondition(ctx context.Context, sel ast.SelectionSet, v UnlockCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnlockCondition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx context.Context, v interface{}) (types.UnlockHash, error) {
	return UnmarshalUnlockHash(v)
}

func (ec *executionContext) marshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx context.Context, sel ast.SelectionSet, v types.UnlockHash) graphql.Marshaler {
	return MarshalUnlockHash(v)
}

func (ec *executionContext) unmarshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx context.Context, v interface{}) (*types.UnlockHash, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx context.Context, sel ast.SelectionSet, v *types.UnlockHash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOUnlockHash2githubcomthreefoldtechrivinetypesUnlockHash(ctx, sel, *v)
}

func (ec *executionContext) marshalOUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx context.Context, sel ast.SelectionSet, v UnlockHashPublicKeyPair) graphql.Marshaler {
	return ec._UnlockHashPublicKeyPair(ctx, sel, &v)
}

func (ec *executionContext) marshalOUnlockHashPublicKeyPair2githubcomthreefoldtechrivinemodulesexplorergraphqlUnlockHashPublicKeyPair(ctx context.Context, sel ast.SelectionSet, v *UnlockHashPublicKeyPair) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnlockHashPublicKeyPair(ctx, sel, v)
}

func (ec *executionContext) marshalOWallet2githubcomthreefoldtechrivinemodulesexplorergraphqlWallet(ctx context.Context, sel ast.SelectionSet, v Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Wallet(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcomthreefoldtechrivinevendorgithubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
