package client

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"math/big"
	"os"
	"strconv"
	"text/tabwriter"

	"github.com/bgentry/speakeasy"
	"github.com/spf13/cobra"

	"github.com/threefoldtech/rivine/modules"
	"github.com/threefoldtech/rivine/pkg/api"
	"github.com/threefoldtech/rivine/pkg/cli"
	clipkg "github.com/threefoldtech/rivine/pkg/cli"
	"github.com/threefoldtech/rivine/types"
)

func createWalletCmd(cli *CommandLineClient) *WalletCommand {
	walletCmd := &walletCmd{cli: cli}

	// create root explore command and all subs
	var (
		rootCmd = &cobra.Command{
			Use:   "wallet",
			Short: "Perform wallet actions",
			Long:  "Generate a new address, send coins to another wallet, or view info about the wallet.",
			Run:   Wrap(walletCmd.balanceCmd),
		}

		blockStakeStatCmd = &cobra.Command{
			Use:   "blockstakestat",
			Short: "Get the stats of the blockstake",
			Long:  "Gives all the statistical info of the blockstake.",
			Run:   Wrap(walletCmd.blockStakesStatsCmd),
		}
		addressCmd = &cobra.Command{
			Use:   "address",
			Short: "Get a new wallet address",
			Long:  "Generate a new wallet address from the wallet's primary seed.",
			Run:   Wrap(walletCmd.addressCmd),
		}
		addressesCmd = &cobra.Command{
			Use:   "addresses",
			Short: "List all addresses",
			Long:  "List all addresses that have been generated by the wallet",
			Run:   Wrap(walletCmd.addressesCmd),
		}
		initCmd = &cobra.Command{
			Use:   "init",
			Short: "Initialize a new wallet",
			Long:  `Generate a new wallet from a randomly generated seed and by default encrypt it.`,
			Run:   Wrap(walletCmd.initCmd),
		}
		recoverCmd = &cobra.Command{
			Use:   "recover",
			Short: "Recover a wallet",
			Long:  `Recover a wallet from the given mnemonic, to be used as primary seed and by default encrypt it.`,
			Run:   Wrap(walletCmd.recoverCmd),
		}
		lockCmd = &cobra.Command{
			Use:   "lock",
			Short: "Lock the wallet",
			Long:  "Lock the wallet, preventing further use",
			Run:   Wrap(walletCmd.lockCmd),
		}
		signTxCmd = &cobra.Command{
			Use:   "sign <txnjson>",
			Short: "Sign inputs from the transaction",
			Long: `Signs as much of the inputs transaction. Iterate over every input, and check if they can be signed
	by any of the keys in the wallet.`,
			Run: Wrap(walletCmd.signTxCmd),
		}
		seedsCmd = &cobra.Command{
			Use:   "seeds",
			Short: "Retrieve information about your seeds",
			Long:  "Retrieves the current seed, how many addresses are remaining, and the rest of your seeds from the wallet",
			Run:   Wrap(walletCmd.seedsCmd),
		}
		balanceCmd = &cobra.Command{
			Use:   "balance",
			Short: "View wallet balance",
			Long:  "View wallet balance, including confirmed and unconfirmed coins and blockstakes.",
			Run:   Wrap(walletCmd.balanceCmd),
		}
		listTransactionsCmd = &cobra.Command{
			Use:   "transactions",
			Short: "View transactions",
			Long: `View transactions related to addresses spendable by the wallet,
	providing a net flow of coins and blockstakes for each transaction.`,
			Run: Wrap(walletCmd.listTransactionsCmd),
		}
		unlockCmd = &cobra.Command{
			Use:   `unlock`,
			Short: "Unlock the wallet",
			Long:  "Decrypt and load the wallet into memory",
			Run:   Wrap(walletCmd.unlockCmd),
		}

		loadCmd = &cobra.Command{
			Use:   "load",
			Short: "Load something into the wallet",
			// Run field is not set, as the load command itself is not a valid command.
			// A subcommand must be provided.
		}
		loadSeedCmd = &cobra.Command{
			Use:   `seed`,
			Short: "Load a seed into the wallet",
			Long:  "Uses the given password to create a new wallet with that as the primary seed",
			Run:   Wrap(walletCmd.loadSeedCmd),
		}

		sendCmd = &cobra.Command{
			Use:   "send",
			Short: "Send either coins or blockstakes",
			Long:  "Send either coins or blockstakes",
			// Run field is not set, as the load command itself is not a valid command.
			// A subcommand must be provided.
		}
		sendCoinsCmd = &cobra.Command{
			Use:   "coins <dest>|<rawCondition> <amount> [<dest>|<rawCondition> <amount>]...",
			Short: "Send coins one or multiple addresses.",
			Long: `Send coins to one or multiple addresses.
	Each 'dest' must be a 78-byte hexadecimal address (Unlock Hash),
	instead of an unlockHash, you can also give a JSON-encoded UnlockCondition directly,
	giving you more control and options over how exactly the block stake is to be unlocked.
	
	Amounts have to be given expressed in the OneCoin unit, and without the unit of currency.
	Decimals are possible and are to be expressed using English conventions.
	
	Amounts have to be given expressed in the OneCoin unit, and without the unit of currency.
	Decimals are possible and have to be defined using the decimal point.
	
	The Minimum Miner Fee will be added on top of the total given amount automatically.
	`,
			Run: walletCmd.sendCoinsCmd,
		}
		sendBlockStakesCmd = &cobra.Command{
			Use:   "blockstakes <dest>|<rawCondition> <amount> [<dest>|<rawCondition> <amount>]..",
			Short: "Send blockstakes to one or multiple addresses",
			Long: `Send blockstakes to one or multiple addresses.
	Each 'dest' must be a 78-byte hexadecimal address (Unlock Hash),
	instead of an unlockHash, you can also give a JSON-encoded UnlockCondition directly,
	giving you more control and options over how exactly the block stake is to be unlocked.
	
	Amounts have to be given expressed in the OneCoin unit, and without the unit of currency.
	Decimals are possible and have to be defined using the decimal point.
	
	The Minimum Miner Fee will be added on top of the total given amount automatically.
	`,
			Run: walletCmd.sendBlockStakesCmd,
		}
		sendTxCmd = &cobra.Command{
			Use:   "transaction <txnjson>",
			Short: "Publish a raw transaction",
			Long:  "Publish a raw transasction. The transaction must be given in json format. The inputs don't need to be related to the current wallet",
			Run:   Wrap(walletCmd.sendTxCmd),
		}

		listCmd = &cobra.Command{
			Use:   "list",
			Short: "List either locked or unlocked unspent outputs",
			// Run field is not set, as the list command itself is not a valid command.
			// A subcommand must be provided.
		}
		listUnlockedCmd = &cobra.Command{
			Use:   "unlocked [address]",
			Args:  cobra.RangeArgs(0, 1),
			Short: "List unlocked coin and blockstake outputs",
			Long: `List all the unlocked coin and blockstake outputs that belong to this wallet.
			
	If an address is given, only unspent unlocked outputs of the wallet linked to that address are shown.
	`,
			Run: walletCmd.listUnlockedCmd,
		}
		listLockedCmd = &cobra.Command{
			Use:   "locked [address]",
			Args:  cobra.RangeArgs(0, 1),
			Short: "List locked coin and blockstake outputs",
			Long: `List all the locked coin and blockstake outputs that belong to this wallet.
	
	If an address is given, only unspent unlocked outputs of the wallet linked to that address are shown.
	`,
			Run: walletCmd.listLockedCmd,
		}

		createCmd = &cobra.Command{
			Use:   "create",
			Short: "Create a coin or blockstake transaction",
			// Run field is not set, as the create command itself is not a valid command.
			// A subcommand must be provided.
		}
		createMultisigAddressesCmd = &cobra.Command{
			Use:   "multisigaddress <minsigsrequired> <address1> <address2> [<address>]...",
			Short: "Create a multisig address",
			Long: `Create a multisig address from the given addresses, which requires at least <minsigrequired>
	signatures to unlock`,
			Args: cobra.MinimumNArgs(3),
			Run:  walletCmd.createMultisigAddressesCmd,
		}
		createCoinTxCmd = &cobra.Command{
			Use:   "cointransaction <parentID>... <dest>|<rawCondition> <amount> [<dest>|<rawCondition> <amount>]...",
			Short: "Create a new coin transaction",
			Long: `Create a new coin transaction using the given parentID's and outputs.
	The outputs can be given as a pair of value and a raw output condition (or
	address, which resolved to a singlesignature condition).
	
	Amounts have to be given expressed in the OneCoin unit, and without the unit of currency.
	Decimals are possible and have to be defined using the decimal point.
	
	The Minimum Miner Fee will be added on top of the total given amount automatically.
	`,
			Run: walletCmd.createCoinTxCmd,
		}
		createBlockStakeTxCmd = &cobra.Command{
			Use:   "blockstaketransaction <parentID>... <dest>|<rawCondition> <amount> [<dest>|<rawCondition> <amount>]...",
			Short: "Create a new blockstake transaction",
			Long: `Create a new blockstake transaction using the given parentID's and outputs.
	The outputs can be given as a pair of value and a raw output condition (or
	address, which resolved to a singlesignature condition).
	
	Amounts have to be given expressed in the OneCoin unit, and without the unit of currency.
	Decimals are possible and have to be defined using the decimal point.
	
	The Minimum Miner Fee will be added on top of the total given amount automatically.
	`,
			Run: walletCmd.createBlockStakeTxCmd,
		}
	)

	// define wallet command tree
	rootCmd.AddCommand(
		addressCmd,
		addressesCmd,
		initCmd,
		recoverCmd,
		lockCmd,
		unlockCmd,
		loadCmd,
		seedsCmd,
		sendCmd,
		balanceCmd,
		listTransactionsCmd,
		blockStakeStatCmd,
		listCmd,
		createCmd,
		signTxCmd)

	sendCmd.AddCommand(
		sendCoinsCmd,
		sendBlockStakesCmd,
		sendTxCmd)

	loadCmd.AddCommand(loadSeedCmd)

	listCmd.AddCommand(
		listUnlockedCmd,
		listLockedCmd)

	createCmd.AddCommand(
		createMultisigAddressesCmd,
		createCoinTxCmd,
		createBlockStakeTxCmd)

	// define config of commands that have a config
	initCmd.Flags().BoolVar(
		&walletCmd.walletInitCfg.Plain,
		"plain", false, "create a plain wallet, requiring no passphrase")
	recoverCmd.Flags().BoolVar(
		&walletCmd.walletRecoverCfg.Plain,
		"plain", false, "Recover seed as a plain wallet, requiring no passphrase")
	recoverCmd.Flags().StringVar(
		&walletCmd.walletRecoverCfg.Seed,
		"seed", "", "define the seed to be recovered as a flag instead of the STDIN")
	loadSeedCmd.Flags().BoolVar(
		&walletCmd.walletLoadSeedCfg.Plain,
		"plain", false, "Load seed into a plain wallet, requiring no passphrase")
	loadSeedCmd.Flags().StringVar(
		&walletCmd.walletLoadSeedCfg.Seed,
		"seed", "", "define the seed to be loaded as a flag instead of the STDIN")

	// custom arbitrarydata flag
	clipkg.ArbitraryDataFlagVar(sendCoinsCmd.Flags(), &walletCmd.sendCoinsCfg.Data,
		"data", "optional arbitrary data (or description) to attach to transaction")
	clipkg.ArbitraryDataFlagVar(sendBlockStakesCmd.Flags(), &walletCmd.sendBlockStakesCfg.Data,
		"data", "optional arbitrary data (or description) to attach to transaction")

	// other custom send coins flags
	sendCoinsCmd.Flags().StringVar(
		&walletCmd.sendCoinsCfg.RefundAddress,
		"refund-address", "", "define a custom refund address")
	sendCoinsCmd.Flags().BoolVar(
		&walletCmd.sendCoinsCfg.RefundAddressNew,
		"refund-address-new", false, "generate a new refund address if a refund needs to happen")

	// other custom send blockstkars flags
	sendBlockStakesCmd.Flags().StringVar(
		&walletCmd.sendBlockStakesCfg.RefundAddress,
		"refund-address", "", "define a custom refund address")
	sendBlockStakesCmd.Flags().BoolVar(
		&walletCmd.sendBlockStakesCfg.RefundAddressNew,
		"refund-address-new", false, "generate a new refund address if a refund needs to happen")

	// return root command
	return &WalletCommand{
		Command:       rootCmd,
		RootCmdSend:   sendCmd,
		RootCmdLoad:   loadCmd,
		RootCmdList:   listCmd,
		RootCmdCreate: createCmd,
	}
}

// WalletCommand returns the Wallet Command as an extended cobra command,
// exposing its sub command groups directly as public properties.
type WalletCommand struct {
	*cobra.Command

	RootCmdSend   *cobra.Command
	RootCmdLoad   *cobra.Command
	RootCmdList   *cobra.Command
	RootCmdCreate *cobra.Command
}

type walletCmd struct {
	cli          *CommandLineClient
	sendCoinsCfg struct {
		Data             []byte
		RefundAddress    string
		RefundAddressNew bool
	}
	sendBlockStakesCfg struct {
		Data             []byte
		RefundAddress    string
		RefundAddressNew bool
	}
	walletInitCfg struct {
		Plain bool
	}
	walletRecoverCfg struct {
		Plain bool
		Seed  string
	}
	walletLoadSeedCfg struct {
		Plain bool
		Seed  string
	}
}

// addressCmd fetches a new address from the wallet that will be able to
// receive coins.
func (walletCmd *walletCmd) addressCmd() {
	addr := new(api.WalletAddressGET)
	err := walletCmd.cli.GetWithResponse("/wallet/address", addr)
	if err != nil {
		cli.DieWithError("Could not generate new address:", err)
	}
	fmt.Printf("Created new address: %s\n", addr.Address)
}

// addressesCmd fetches the list of addresses that the wallet knows.
func (walletCmd *walletCmd) addressesCmd() {
	addrs := new(api.WalletAddressesGET)
	err := walletCmd.cli.GetWithResponse("/wallet/addresses", addrs)
	if err != nil {
		cli.DieWithError("Failed to fetch addresses:", err)
	}
	for _, addr := range addrs.Addresses {
		fmt.Println(addr)
	}
}

// initCmd encrypts the wallet with the given password
func (walletCmd *walletCmd) initCmd() {
	var er api.WalletInitPOST

	var data string
	if !walletCmd.walletInitCfg.Plain {
		fmt.Println("You have to provide a passphrase!")
		fmt.Println("If you have an existing mnemonic you can use the recover wallet command instead.")

		passphrase, err := speakeasy.Ask("Wallet passphrase: ")
		if err != nil {
			cli.Die("Reading passphrase failed:", err)
		}
		if passphrase == "" {
			cli.Die("passphrase is required and cannot be empty")
		}

		repassphrase, err := speakeasy.Ask("Reenter passphrase: ")
		if err != nil {
			cli.Die("Reading passphrase failed:", err)
		}

		if repassphrase != passphrase {
			cli.Die("Given passphrases do not match !!")
		}

		data = fmt.Sprintf("passphrase=%s", passphrase)
	}

	err := walletCmd.cli.PostWithResponse("/wallet/init", data, &er)
	if err != nil {
		if walletCmd.walletInitCfg.Plain {
			cli.DieWithError("Error when creating plain wallet:", err)
		} else {
			cli.DieWithError("Error when creating encrypted wallet:", err)
		}
	}

	fmt.Printf("Mnemonic of primary seed:\n%s\n\n", er.PrimarySeed)
	if !walletCmd.walletInitCfg.Plain {
		fmt.Printf("Wallet encrypted with given passphrase\n")
	}
}

// recoverCmd encrypts the wallet with the given password,
// recovering a wallet for the given menmeonic to be used as primary seed.
func (walletCmd *walletCmd) recoverCmd() {
	var er api.WalletInitPOST

	var data string
	if !walletCmd.walletRecoverCfg.Plain {
		fmt.Println("You have to provide a passphrase and existing mnemonic!")
		fmt.Println("If you have no existing mnemonic use the init wallet command instead!")

		passphrase, err := speakeasy.Ask("Wallet passphrase: ")
		if err != nil {
			cli.Die("Reading passphrase failed:", err)
		}
		if passphrase == "" {
			cli.Die("passphrase is required and cannot be empty")
		}

		repassphrase, err := speakeasy.Ask("Reenter passphrase: ")
		if err != nil {
			cli.Die("Reading passphrase failed:", err)
		}

		if repassphrase != passphrase {
			cli.Die("Given passphrases do not match !!")
		}

		data = fmt.Sprintf("passphrase=%s&", passphrase)
	}

	mnemonic := walletCmd.walletRecoverCfg.Seed
	if mnemonic == "" {
		var err error
		mnemonic, err = speakeasy.Ask("Enter existing mnemonic to be used as primary seed: ")
		if err != nil {
			cli.Die("Reading mnemonic failed:", err)
		}
	}
	seed, err := modules.InitialSeedFromMnemonic(mnemonic)
	if err != nil {
		cli.Die("Invalid mnemonic given:", err)
	}
	data += fmt.Sprintf("seed=%s", seed.String())

	err = walletCmd.cli.PostWithResponse("/wallet/init", data, &er)
	if err != nil {
		if walletCmd.walletRecoverCfg.Plain {
			cli.DieWithError("Error when creating plain wallet:", err)
		} else {
			cli.DieWithError("Error when creating encrypted wallet:", err)
		}
	}

	if er.PrimarySeed != mnemonic {
		cli.Die("Wallet was created, but returned primary seed mnemonic was unexpected:\n\n" + er.PrimarySeed)
	}

	fmt.Printf("Mnemonic of primary seed:\n%s\n\n", er.PrimarySeed)
	if !walletCmd.walletRecoverCfg.Plain {
		fmt.Printf("Wallet encrypted with given passphrase\n")
	}
}

// loadSeedCmd adds a seed to the wallet's list of seeds
func (walletCmd *walletCmd) loadSeedCmd() {
	var data string
	if !walletCmd.walletLoadSeedCfg.Plain {
		passphrase, err := speakeasy.Ask("Wallet passphrase: ")
		if err != nil {
			cli.Die("Reading passphrase failed:", err)
		}
		data = fmt.Sprintf("passphrase=%s&", passphrase)
	}
	seed := walletCmd.walletLoadSeedCfg.Seed
	if seed == "" {
		var err error
		seed, err = speakeasy.Ask("Existing Mnemonic: ")
		if err != nil {
			cli.Die("Reading seed failed:", err)
		}
	}
	data += fmt.Sprintf("mnemonic=%s", seed)
	err := walletCmd.cli.Post("/wallet/seed", data)
	if err != nil {
		cli.DieWithError("Could not add seed:", err)
	}
	fmt.Println("Added Key")
}

// lockCmd locks the wallet
func (walletCmd *walletCmd) lockCmd() {
	err := walletCmd.cli.Post("/wallet/lock", "")
	if err != nil {
		cli.DieWithError("Could not lock wallet:", err)
	}
}

// seedsCmd returns the current seed {
func (walletCmd *walletCmd) seedsCmd() {
	var seedInfo api.WalletSeedsGET
	err := walletCmd.cli.GetWithResponse("/wallet/seeds", &seedInfo)
	if err != nil {
		cli.DieWithError("Error retrieving the current seed:", err)
	}
	fmt.Printf("Primary Seed: %s\n"+
		"Addresses Remaining %d\n"+
		"All Seeds:\n", seedInfo.PrimarySeed, seedInfo.AddressesRemaining)
	for _, seed := range seedInfo.AllSeeds {
		fmt.Println(seed)
	}
}

// sendCoinsCmd sends siacoins to one or multiple destination addresses.
func (walletCmd *walletCmd) sendCoinsCmd(cmd *cobra.Command, args []string) {
	currencyConvertor := walletCmd.cli.CreateCurrencyConvertor()
	pairs, err := parsePairedOutputs(args, currencyConvertor.ParseCoinString)
	if err != nil {
		cmd.UsageFunc()(cmd)
		cli.Die(err)
	}

	body := api.WalletCoinsPOST{
		CoinOutputs: make([]types.CoinOutput, len(pairs)),
		Data:        []byte(walletCmd.sendCoinsCfg.Data),
	}
	for i, pair := range pairs {
		body.CoinOutputs[i] = types.CoinOutput{
			Value:     pair.Value,
			Condition: pair.Condition,
		}
	}
	if walletCmd.sendCoinsCfg.RefundAddress != "" {
		// use the specified address as the refund address if a refund has to happen
		var uh types.UnlockHash
		err = uh.LoadString(walletCmd.sendCoinsCfg.RefundAddress)
		if err != nil {
			cli.DieWithError("invalid refund address specified", err)
		}
		body.RefundAddress = &uh
	} else if walletCmd.sendCoinsCfg.RefundAddressNew {
		// ensure the daemon generates a new refund address if a refund needs to happen
		body.GenerateRefundAddress = true
	}

	bytes, err := json.Marshal(&body)
	if err != nil {
		cli.Die("Failed to JSON Marshal the input body:", err)
	}
	var resp api.WalletCoinsPOSTResp
	err = walletCmd.cli.PostWithResponse("/wallet/coins", string(bytes), &resp)
	if err != nil {
		cli.DieWithError("Could not send coins:", err)
	}
	fmt.Println("Succesfully sent coins as transaction " + resp.TransactionID.String())
	for _, co := range body.CoinOutputs {
		fmt.Printf("Sent %s to %s (using ConditionType %d)\n",
			currencyConvertor.ToCoinStringWithUnit(co.Value), co.Condition.UnlockHash(),
			co.Condition.ConditionType())
	}
}

// sendBlockStakesCmd sends block stakes to one or multiple destination addresses.
func (walletCmd *walletCmd) sendBlockStakesCmd(cmd *cobra.Command, args []string) {
	pairs, err := parsePairedOutputs(args, stringToBlockStakes)
	if err != nil {
		cmd.UsageFunc()(cmd)
		cli.Die(err)
	}

	body := api.WalletBlockStakesPOST{
		BlockStakeOutputs: make([]types.BlockStakeOutput, len(pairs)),
		Data:              []byte(walletCmd.sendBlockStakesCfg.Data),
	}
	for i, pair := range pairs {
		body.BlockStakeOutputs[i] = types.BlockStakeOutput{
			Value:     pair.Value,
			Condition: pair.Condition,
		}
	}
	if walletCmd.sendBlockStakesCfg.RefundAddress != "" {
		// use the specified address as the refund address if a refund has to happen
		var uh types.UnlockHash
		err = uh.LoadString(walletCmd.sendBlockStakesCfg.RefundAddress)
		if err != nil {
			cli.DieWithError("invalid refund address specified", err)
		}
		body.RefundAddress = &uh
	} else if walletCmd.sendBlockStakesCfg.RefundAddressNew {
		// ensure the daemon generates a new refund address if a refund needs to happen
		body.GenerateRefundAddress = true
	}

	bytes, err := json.Marshal(&body)
	if err != nil {
		cli.Die("Failed to JSON Marshal the input body:", err)
	}
	var resp api.WalletBlockStakesPOSTResp
	err = walletCmd.cli.PostWithResponse("/wallet/blockstakes", string(bytes), &resp)
	if err != nil {
		cli.DieWithError("Could not send block stakes:", err)
	}
	fmt.Println("Succesfully sent blockstakes as transaction " + resp.TransactionID.String())
	for _, bo := range body.BlockStakeOutputs {
		fmt.Printf("Sent %s BS to %s (using ConditionType %d)\n",
			bo.Value, bo.Condition.UnlockHash(), bo.Condition.ConditionType())
	}
}

type outputPair struct {
	Condition types.UnlockConditionProxy
	Value     types.Currency
}

// parseCurrencyString takes the string representation of a currency value
type parseCurrencyString func(string) (types.Currency, error)

func stringToBlockStakes(input string) (types.Currency, error) {
	bsv, err := strconv.ParseUint(input, 10, 64)
	return types.NewCurrency64(bsv), err
}

func parsePairedOutputs(args []string, parseCurrency parseCurrencyString) (pairs []outputPair, err error) {
	argn := len(args)
	if argn < 2 {
		err = errors.New("not enough arguments, at least 2 required")
		return
	}
	if argn%2 != 0 {
		err = errors.New("arguments have to be given in pairs of '<dest>|<rawCondition>'+'<value>'")
		return
	}

	for i := 0; i < argn; i += 2 {
		// parse value first, as it's the one without any possibility of ambiguity
		var pair outputPair
		pair.Value, err = parseCurrency(args[i+1])
		if err != nil {
			err = fmt.Errorf("failed to parse amount/value for output #%d: %v", i/2, err)
			return
		}

		// try to parse it as an unlock hash
		var uh types.UnlockHash
		err = uh.LoadString(args[i])
		if err == nil {
			// parsing as an unlock hash was succesfull, store the pair and continue to the next pair
			pair.Condition = types.NewCondition(types.NewUnlockHashCondition(uh))
			pairs = append(pairs, pair)
			continue
		}

		// try to parse it as a JSON-encoded unlock condition
		err = pair.Condition.UnmarshalJSON([]byte(args[i]))
		if err != nil {
			err = fmt.Errorf("condition has to be UnlockHash or JSON-encoded UnlockCondition, output #%d's was neither", i/2)
			return
		}
		pairs = append(pairs, pair)
	}
	return
}

// blockStakesStatsCmd gives all statistical info of blockstake
func (walletCmd *walletCmd) blockStakesStatsCmd() {
	currencyConvertor := walletCmd.cli.CreateCurrencyConvertor()

	bsstat := new(api.WalletBlockStakeStatsGET)
	err := walletCmd.cli.GetWithResponse("/wallet/blockstakestats", bsstat)
	if err != nil {
		cli.DieWithError("Could not gen blockstake info:", err)
	}
	fmt.Printf("BlockStake stats:\n")
	fmt.Printf("Total active Blockstake is %v\n", bsstat.TotalActiveBlockStake)
	fmt.Printf("This account has %v Blockstake\n", bsstat.TotalBlockStake)
	fmt.Printf("%v of last %v Blocks created (theoretically %v)\n", bsstat.TotalBCLast1000, bsstat.BlockCount, bsstat.TotalBCLast1000t)

	fmt.Printf("containing %v fee \n",
		currencyConvertor.ToCoinStringWithUnit(bsstat.TotalFeeLast1000))

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', tabwriter.AlignRight|tabwriter.Debug)
	fmt.Fprintln(w, "state\t#BlockStake\tUTXO hash\t")

	for i, BSstate := range bsstat.BlockStakeState {
		state := "active"
		if BSstate == 0 {
			state = "not active"
		}
		fmt.Fprintf(w, "%v\t%v\t%v\t\n", state, bsstat.BlockStakeNumOf[i], bsstat.BlockStakeUTXOAddress[i])
	}
	w.Flush()
}

// balanceCmd retrieves and displays information about the wallet.
func (walletCmd *walletCmd) balanceCmd() {
	currencyConvertor := walletCmd.cli.CreateCurrencyConvertor()

	status := new(api.WalletGET)
	err := walletCmd.cli.GetWithResponse("/wallet", status)
	if err != nil {
		cli.DieWithError("Could not get wallet status:", err)
	}
	encStatus := "Unencrypted"
	if status.Encrypted {
		encStatus = "Encrypted"
	}
	if !status.Unlocked {
		cli.DieWithExitCode(cli.ExitCodeUsage, fmt.Sprintf(`Wallet status:
%v, Locked
Unlock the wallet to view balance
`, encStatus))
	}

	unconfirmedBalance := status.ConfirmedCoinBalance.Add(status.UnconfirmedIncomingCoins).Sub(status.UnconfirmedOutgoingCoins)
	var delta string
	if unconfirmedBalance.Cmp(status.ConfirmedCoinBalance) >= 0 {
		delta = "+ " + currencyConvertor.ToCoinStringWithUnit(unconfirmedBalance.Sub(status.ConfirmedCoinBalance))
	} else {
		delta = "- " + currencyConvertor.ToCoinStringWithUnit(status.ConfirmedCoinBalance.Sub(unconfirmedBalance))
	}

	fmt.Printf(`Wallet status:
%s, Unlocked
Confirmed Balance:   %v
Locked Balance:      %v
Unconfirmed Delta:   %v
BlockStakes:         %v BS
`, encStatus, currencyConvertor.ToCoinStringWithUnit(status.ConfirmedCoinBalance),
		currencyConvertor.ToCoinStringWithUnit(status.ConfirmedLockedCoinBalance),
		delta, status.BlockStakeBalance)
	if !status.LockedBlockStakeBalance.IsZero() {
		fmt.Printf("Locked BlockStakes:  %v BS\n", status.LockedBlockStakeBalance)
	}

	if len(status.MultiSigWallets) > 0 {
		fmt.Println()
		fmt.Println("Multisig Wallets:")
	}

	for _, wallet := range status.MultiSigWallets {
		// Print separator
		fmt.Println()
		fmt.Println("==============================================================================")
		fmt.Println()

		unconfirmedBalance := wallet.ConfirmedCoinBalance.Add(wallet.UnconfirmedIncomingCoins).Sub(wallet.UnconfirmedOutgoingCoins)
		var coindelta string
		if unconfirmedBalance.Cmp(wallet.ConfirmedCoinBalance) >= 0 {
			coindelta = "+ " + currencyConvertor.ToCoinStringWithUnit(unconfirmedBalance.Sub(wallet.ConfirmedCoinBalance))
		} else {
			coindelta = "- " + currencyConvertor.ToCoinStringWithUnit(wallet.ConfirmedCoinBalance.Sub(unconfirmedBalance))
		}

		unconfirmedBlockStakeBalance := wallet.ConfirmedBlockStakeBalance.Add(wallet.UnconfirmedIncomingBlockStakes).Sub(wallet.UnconfirmedOutgoingBlockStakes)
		var bsdelta string
		if unconfirmedBlockStakeBalance.Cmp(wallet.ConfirmedBlockStakeBalance) >= 0 {
			bsdelta = "+ " + unconfirmedBalance.Sub(wallet.ConfirmedBlockStakeBalance).String()
		} else {
			bsdelta = "- " + wallet.ConfirmedBlockStakeBalance.Sub(unconfirmedBlockStakeBalance).String()
		}

		fmt.Printf("%v\n", wallet.Address)
		fmt.Printf("Confirmed Balance:            %v\n", currencyConvertor.ToCoinStringWithUnit(wallet.ConfirmedCoinBalance))
		if !wallet.ConfirmedLockedCoinBalance.IsZero() {
			fmt.Printf("Locked Balance:               %v\n", currencyConvertor.ToCoinStringWithUnit(wallet.ConfirmedLockedCoinBalance))
		}
		if wallet.UnconfirmedIncomingCoins.Cmp(wallet.UnconfirmedOutgoingCoins) != 0 {
			fmt.Printf("Unconfirmed Delta:            %v\n", coindelta)
		}
		if !wallet.ConfirmedBlockStakeBalance.IsZero() {
			fmt.Printf("BlockStakes:                  %v BS\n", wallet.ConfirmedBlockStakeBalance)
		}
		if !wallet.ConfirmedLockedBlockStakeBalance.IsZero() {
			fmt.Printf("Locked BlockStakes:           %v BS\n", wallet.ConfirmedLockedBlockStakeBalance)
		}
		if wallet.UnconfirmedIncomingBlockStakes.Cmp(wallet.UnconfirmedOutgoingBlockStakes) != 0 {
			fmt.Printf("Unconfirmed blockstake delta: %v BS\n", bsdelta)
		}

		fmt.Println()
		fmt.Println("Possible signatories:")
		for _, uh := range wallet.Owners {
			fmt.Println(uh)
		}
		fmt.Println()
		fmt.Println("Minimum signatures required:", wallet.MinSigs)
	}
}

// listTransactionsCmd lists all of the transactions related to the wallet,
// providing a net flow of siacoins and siafunds for each.
func (walletCmd *walletCmd) listTransactionsCmd() {
	wtg := new(api.WalletTransactionsGET)
	err := walletCmd.cli.GetWithResponse("/wallet/transactions?startheight=0&endheight=10000000", wtg)
	if err != nil {
		cli.DieWithError("Could not fetch transaction history:", err)
	}

	multiSigWalletTxns := make(map[types.UnlockHash][]modules.ProcessedTransaction)
	txns := append(wtg.ConfirmedTransactions, wtg.UnconfirmedTransactions...)

	if len(txns) == 0 {
		fmt.Println("This wallet has no transaction related to it.")
		return
	}

	fmt.Println("    [height]                                                   [transaction id]       [net coins]   [net blockstakes]")
	for _, txn := range txns {
		var relatedMultiSigUnlockHashes []types.UnlockHash
		// Determine the number of outgoing siacoins and siafunds.
		var outgoingSiacoins types.Currency
		var outgoingBlockStakes types.Currency
		var rootWalletOwned bool
		for _, input := range txn.Inputs {
			if input.FundType == types.SpecifierCoinInput && input.WalletAddress {
				rootWalletOwned = true
				outgoingSiacoins = outgoingSiacoins.Add(input.Value)
			}
			if input.FundType == types.SpecifierBlockStakeInput && input.WalletAddress {
				rootWalletOwned = true
				outgoingBlockStakes = outgoingBlockStakes.Add(input.Value)
			}
			if input.RelatedAddress.Type == types.UnlockTypeMultiSig {
				relatedMultiSigUnlockHashes = append(relatedMultiSigUnlockHashes, input.RelatedAddress)
			}
		}

		// Determine the number of incoming siacoins and siafunds.
		var incomingSiacoins types.Currency
		var incomingBlockStakes types.Currency
		for _, output := range txn.Outputs {
			if output.FundType == types.SpecifierMinerPayout {
				rootWalletOwned = true
				incomingSiacoins = incomingSiacoins.Add(output.Value)
			}
			if output.FundType == types.SpecifierCoinOutput && output.WalletAddress {
				rootWalletOwned = true
				incomingSiacoins = incomingSiacoins.Add(output.Value)
			}
			if output.FundType == types.SpecifierBlockStakeOutput && output.WalletAddress {
				rootWalletOwned = true
				incomingBlockStakes = incomingBlockStakes.Add(output.Value)
			}
			if output.RelatedAddress.Type == types.UnlockTypeMultiSig {
				relatedMultiSigUnlockHashes = append(relatedMultiSigUnlockHashes, output.RelatedAddress)
			}
		}

		// Remember the txn to print it in case there are related special conditions
		for _, uh := range relatedMultiSigUnlockHashes {
			multiSigWalletTxns[uh] = append(multiSigWalletTxns[uh], txn)
		}
		// Only print here if there is a direct relation to the root wallet
		if !rootWalletOwned {
			continue
		}

		// Convert the siacoins to a float.
		incomingSiacoinsFloat, _ := new(big.Rat).SetFrac(incomingSiacoins.Big(), walletCmd.cli.Config.CurrencyUnits.OneCoin.Big()).Float64()
		outgoingSiacoinsFloat, _ := new(big.Rat).SetFrac(outgoingSiacoins.Big(), walletCmd.cli.Config.CurrencyUnits.OneCoin.Big()).Float64()

		// Print the results.
		if txn.ConfirmationHeight < 1e9 {
			fmt.Printf("%12v", txn.ConfirmationHeight-1)
		} else {
			fmt.Printf(" unconfirmed")
		}
		fmt.Printf("%67v%15.2f %s", txn.TransactionID, incomingSiacoinsFloat-outgoingSiacoinsFloat, walletCmd.cli.Config.CurrencyCoinUnit)
		incomingBlockStakeBigInt := incomingBlockStakes.Big()
		outgoingBlockStakeBigInt := outgoingBlockStakes.Big()
		fmt.Printf("%14s BS\n", new(big.Int).Sub(incomingBlockStakeBigInt, outgoingBlockStakeBigInt).String())
	}

	if len(multiSigWalletTxns) > 0 {
		for uh, txns := range multiSigWalletTxns {
			for _, txn := range txns {
				fmt.Println()
				fmt.Println("=====================================================================================================================")
				fmt.Println()

				fmt.Println("Wallet Address:", uh)
				fmt.Println()
				fmt.Println("    [height]                                             [transaction/block id]       [net coins]   [net blockstakes]")

				// Determine the number of outgoing siacoins and siafunds.
				var outgoingSiacoins types.Currency
				var outgoingBlockStakes types.Currency
				for _, input := range txn.Inputs {
					if input.FundType == types.SpecifierCoinInput && input.RelatedAddress.Cmp(uh) == 0 {
						outgoingSiacoins = outgoingSiacoins.Add(input.Value)
					}
					if input.FundType == types.SpecifierBlockStakeInput && input.RelatedAddress.Cmp(uh) == 0 {
						outgoingBlockStakes = outgoingBlockStakes.Add(input.Value)
					}
				}

				// Determine the number of incoming siacoins and siafunds.
				var incomingSiacoins types.Currency
				var incomingBlockStakes types.Currency
				for _, output := range txn.Outputs {
					if output.FundType == types.SpecifierMinerPayout {
						incomingSiacoins = incomingSiacoins.Add(output.Value)
					}
					if output.FundType == types.SpecifierCoinOutput && output.RelatedAddress.Cmp(uh) == 0 {
						incomingSiacoins = incomingSiacoins.Add(output.Value)
					}
					if output.FundType == types.SpecifierBlockStakeOutput && output.RelatedAddress.Cmp(uh) == 0 {
						incomingBlockStakes = incomingBlockStakes.Add(output.Value)
					}
				}

				// Convert the siacoins to a float.
				incomingSiacoinsFloat, _ := new(big.Rat).SetFrac(incomingSiacoins.Big(),
					walletCmd.cli.Config.CurrencyUnits.OneCoin.Big()).Float64()
				outgoingSiacoinsFloat, _ := new(big.Rat).SetFrac(outgoingSiacoins.Big(),
					walletCmd.cli.Config.CurrencyUnits.OneCoin.Big()).Float64()

				// Print the results.
				if txn.ConfirmationHeight < 1e9 {
					fmt.Printf("%12v", txn.ConfirmationHeight-1)
				} else {
					fmt.Printf(" unconfirmed")
				}
				fmt.Printf("%67v%15.2f %s", txn.TransactionID, incomingSiacoinsFloat-outgoingSiacoinsFloat,
					walletCmd.cli.Config.CurrencyCoinUnit)
				incomingBlockStakeBigInt := incomingBlockStakes.Big()
				outgoingBlockStakeBigInt := outgoingBlockStakes.Big()
				fmt.Printf("%14s BS\n", new(big.Int).Sub(incomingBlockStakeBigInt, outgoingBlockStakeBigInt).String())
			}
		}
	}
}

// unlockCmd unlocks a saved wallet
func (walletCmd *walletCmd) unlockCmd() {
	password, err := speakeasy.Ask("Wallet password: ")
	if err != nil {
		cli.Die("Reading password failed:", err)
	}
	fmt.Println("Unlocking the wallet. This may take several minutes...")
	qs := fmt.Sprintf("passphrase=%s", password)
	err = walletCmd.cli.Post("/wallet/unlock", qs)
	if err != nil {
		cli.DieWithError("Could not unlock wallet:", err)
	}
	fmt.Println("Wallet unlocked")
}

// sendTxCmd sends commits a transaction in json format
// to the transaction pool
func (walletCmd *walletCmd) sendTxCmd(txnjson string) {
	var resp api.TransactionPoolPOST
	err := walletCmd.cli.PostWithResponse("/transactionpool/transactions", txnjson, &resp)
	if err != nil {
		cli.DieWithError("Could not publish transaction:", err)
	}
	fmt.Println("Transaction published, transaction id:", resp.TransactionID)
}

func (walletCmd *walletCmd) listUnlockedCmd(_ *cobra.Command, args []string) {
	currencyConvertor := walletCmd.cli.CreateCurrencyConvertor()

	var (
		err          error
		address      types.UnlockHash
		addressGiven = len(args) == 1
	)
	if addressGiven {
		err = address.LoadString(args[0])
		if err != nil {
			cli.Die("failed to parse given wallet address: ", err)
		}
	}

	var resp api.WalletListUnlockedGET
	err = walletCmd.cli.GetWithResponse("/wallet/unlocked", &resp)
	if err != nil {
		cli.DieWithError("failed to get unlocked outputs: ", err)
	}

	if addressGiven {
		// filter out all outputs we do not care about
		for idx := 0; idx < len(resp.UnlockedCoinOutputs); {
			if resp.UnlockedCoinOutputs[idx].Output.Condition.UnlockHash().Cmp(address) == 0 {
				idx++
				continue
			}
			resp.UnlockedCoinOutputs = append(
				resp.UnlockedCoinOutputs[:idx],
				resp.UnlockedCoinOutputs[idx+1:]...)
		}
		for idx := 0; idx < len(resp.UnlockedBlockstakeOutputs); {
			if resp.UnlockedBlockstakeOutputs[idx].Output.Condition.UnlockHash().Cmp(address) == 0 {
				idx++
				continue
			}
			resp.UnlockedBlockstakeOutputs = append(
				resp.UnlockedBlockstakeOutputs[:idx],
				resp.UnlockedBlockstakeOutputs[idx+1:]...)
		}
	}

	if len(resp.UnlockedBlockstakeOutputs) == 0 && len(resp.UnlockedCoinOutputs) == 0 {
		if addressGiven {
			fmt.Println("No unlocked outputs matched to address: " + address.String())
		} else {
			fmt.Println("No unlocked outputs")
		}
		return
	}

	jsonOutput := json.NewEncoder(os.Stdout)

	if len(resp.UnlockedCoinOutputs) > 0 {
		fmt.Println("Unlocked unspent coin outputs:")
		for _, uco := range resp.UnlockedCoinOutputs {
			fmt.Println("ID:", uco.ID)
			fmt.Println("Value:", currencyConvertor.ToCoinStringWithUnit(uco.Output.Value))
			fmt.Println("Condition:")
			jsonOutput.Encode(uco.Output)
			fmt.Println()
		}
	}

	if len(resp.UnlockedBlockstakeOutputs) > 0 {
		fmt.Println("Unlocked unspent blockstake outputs:")
		for _, ubso := range resp.UnlockedBlockstakeOutputs {
			fmt.Println("ID:", ubso.ID)
			fmt.Println("Value:", ubso.Output.Value, "BS")
			fmt.Println("Condition:")
			jsonOutput.Encode(ubso.Output)
			fmt.Println()
		}
	}
}

func (walletCmd *walletCmd) listLockedCmd(_ *cobra.Command, args []string) {
	currencyConvertor := walletCmd.cli.CreateCurrencyConvertor()

	var (
		err          error
		address      types.UnlockHash
		addressGiven = len(args) == 1
	)
	if addressGiven {
		err = address.LoadString(args[0])
		if err != nil {
			cli.Die("failed to parse given wallet address: ", err)
		}
	}

	var resp api.WalletListLockedGET
	err = walletCmd.cli.GetWithResponse("/wallet/locked", &resp)
	if err != nil {
		cli.DieWithError("Could not get locked outputs: ", err)
	}

	if addressGiven {
		// filter out all outputs we do not care about
		for idx := 0; idx < len(resp.LockedCoinOutputs); {
			if resp.LockedCoinOutputs[idx].Output.Condition.UnlockHash().Cmp(address) == 0 {
				idx++
				continue
			}
			resp.LockedCoinOutputs = append(
				resp.LockedCoinOutputs[:idx],
				resp.LockedCoinOutputs[idx+1:]...)
		}
		for idx := 0; idx < len(resp.LockedBlockstakeOutputs); {
			if resp.LockedBlockstakeOutputs[idx].Output.Condition.UnlockHash().Cmp(address) == 0 {
				idx++
				continue
			}
			resp.LockedBlockstakeOutputs = append(
				resp.LockedBlockstakeOutputs[:idx],
				resp.LockedBlockstakeOutputs[idx+1:]...)
		}
	}

	if len(resp.LockedBlockstakeOutputs) == 0 && len(resp.LockedCoinOutputs) == 0 {
		if addressGiven {
			fmt.Println("No locked outputs matched to address: " + address.String())
		} else {
			fmt.Println("No locked outputs")
		}
		return
	}

	jsonOutput := json.NewEncoder(os.Stdout)

	if len(resp.LockedCoinOutputs) > 0 {
		fmt.Println("Locked unspent coin outputs:")
		for _, uco := range resp.LockedCoinOutputs {
			fmt.Println("ID:", uco.ID)
			fmt.Println("Value:", currencyConvertor.ToCoinStringWithUnit(uco.Output.Value))
			fmt.Println("Condition:")
			jsonOutput.Encode(uco.Output)
			fmt.Println()
		}
	}

	if len(resp.LockedBlockstakeOutputs) > 0 {
		fmt.Println("Locked unspent blockstake outputs:")
		for _, ubso := range resp.LockedBlockstakeOutputs {
			fmt.Println("ID:", ubso.ID)
			fmt.Println("Value:", ubso.Output.Value, "BS")
			fmt.Println("Condition:")
			jsonOutput.Encode(ubso.Output)
			fmt.Println()
		}
	}
}

func (walletCmd *walletCmd) createMultisigAddressesCmd(cmd *cobra.Command, args []string) {
	msr, err := strconv.ParseUint(args[0], 10, 64)
	if err != nil {
		cli.Die(err)
	}

	if uint64(len(args[1:])) < msr {
		cli.Die("Invalid amount of signatures required")
	}

	uhs := types.UnlockHashSlice{}
	var uh types.UnlockHash
	for _, addr := range args[1:] {
		err = uh.LoadString(addr)
		if err != nil {
			cli.Die("Failed to load unlock hash:", err)
		}
		uhs = append(uhs, uh)
	}

	multiSigCond := types.NewMultiSignatureCondition(uhs, msr)
	fmt.Println("Multisig address:", multiSigCond.UnlockHash())
}

func (walletCmd *walletCmd) createCoinTxCmd(cmd *cobra.Command, args []string) {
	currencyConvertor := walletCmd.cli.CreateCurrencyConvertor()

	// parse first arguments as coin inputs
	inputs := []types.CoinOutputID{}
	var id types.CoinOutputID
	for _, possibleInputID := range args {
		if err := id.LoadString(possibleInputID); err != nil {
			break
		}
		inputs = append(inputs, id)
	}

	// Check that the remaining args are condition + value pairs
	if (len(args)-len(inputs))%2 != 0 {
		cmd.UsageFunc()(cmd)
		cli.Die("Invalid arguments. Arguments must be of the form <parentID>... <dest>|<rawCondition> <amount> [<dest>|<rawCondition> <amount>]...")
	}

	// parse the remainder as output coditions and values
	pairs, err := parsePairedOutputs(args[len(inputs):], currencyConvertor.ParseCoinString)
	if err != nil {
		cmd.UsageFunc()(cmd)
		cli.Die(err)
	}

	body := api.WalletCreateTransactionPOST{}
	body.CoinInputs = inputs
	for _, pair := range pairs {
		body.CoinOutputs = append(body.CoinOutputs, types.CoinOutput{Value: pair.Value, Condition: pair.Condition})
	}

	buffer := bytes.NewBuffer(nil)
	err = json.NewEncoder(buffer).Encode(body)
	if err != nil {
		cli.Die("Could not create raw transaction from inputs and outputs: ", err)
	}
	var resp api.WalletCreateTransactionRESP
	err = walletCmd.cli.PostWithResponse("/wallet/create/transaction", buffer.String(), &resp)
	if err != nil {
		cli.DieWithError("Failed to create transaction:", err)
	}

	json.NewEncoder(os.Stdout).Encode(resp.Transaction)
}

func (walletCmd *walletCmd) createBlockStakeTxCmd(cmd *cobra.Command, args []string) {
	// parse first arguments as coin inputs
	inputs := []types.BlockStakeOutputID{}
	var id types.BlockStakeOutputID
	for _, possibleInputID := range args {
		if err := id.LoadString(possibleInputID); err != nil {
			break
		}
		inputs = append(inputs, id)
	}

	// Check that the remaining args are condition + value pairs
	if (len(args)-len(inputs))%2 != 0 {
		cmd.UsageFunc()(cmd)
		cli.Die("Invalid arguments. Arguments must be of the form <parentID>... <dest>|<rawCondition> <amount> [<dest>|<rawCondition> <amount>]...")
	}

	// parse the remainder as output coditions and values
	pairs, err := parsePairedOutputs(args[len(inputs):], stringToBlockStakes)
	if err != nil {
		cmd.UsageFunc()(cmd)
		cli.Die(err)
	}

	body := api.WalletCreateTransactionPOST{}
	body.BlockStakeInputs = inputs
	for _, pair := range pairs {
		body.BlockStakeOutputs = append(body.BlockStakeOutputs, types.BlockStakeOutput{Value: pair.Value, Condition: pair.Condition})
	}

	buffer := bytes.NewBuffer(nil)
	err = json.NewEncoder(buffer).Encode(body)
	if err != nil {
		cli.Die("Could not create raw transaction from inputs and outputs: ", err)
	}
	var resp api.WalletCreateTransactionRESP
	err = walletCmd.cli.PostWithResponse("/wallet/create/transaction", buffer.String(), &resp)
	if err != nil {
		cli.DieWithError("Failed to create transaction:", err)
	}

	json.NewEncoder(os.Stdout).Encode(resp.Transaction)
}

func (walletCmd *walletCmd) signTxCmd(txnjson string) {
	var txn types.Transaction
	err := walletCmd.cli.PostWithResponse("/wallet/sign", txnjson, &txn)
	if err != nil {
		cli.DieWithError("Failed to sign transaction:", err)
	}

	json.NewEncoder(os.Stdout).Encode(txn)
}
